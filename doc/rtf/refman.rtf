{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment Elevator Simulator  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2.0 \par
}}Elevator Simulator}
{\comment Generated by doxygen1.8.18.}
{\creatim \yr2020\mo4\dy24\hr17\min10\sec34}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt Elevator Simulator}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 2.0\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Fri Apr 24 2020 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Introduction{\tc \v Introduction}\par \pard\plain 
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Elevator simulation is a software to simulate the operations of multiple elevators in a commercial building, by creating an algorithm.\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Requirement
\par}
{\tc\tcl2 \v Requirement}
Software simulates Elevator scheduling in a building for an day by reading the input file with Paaseger ID,timestamp,start and destination floor. The text file must be stored in data/input.txt.\par}
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Assumption
\par}
{\tc\tcl2 \v Assumption}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
User gives the number of floors and elevators in the building, the value should be less than or equal to 100. In dynamic case this is reduced to 10 to make all elevators fit the screen.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The elevators are assumed to be at the same location in the building.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
At the start of the simulation all the elevators are assumed to be on the 1st floor.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The weight of each passenger is assumed to be constant. This allows the simulator to establish weight limits as the number of passengers in the elevator. In this program it is set to 10.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
A fixed time has been assumed for lifts to move from x floor to x+1 and x-1 floors.Each elevator takes 3 seconds to go from one floor to another floor.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The time that the elevator stops on a floor depends on that number of passengers getting in or out. It is assumed that it takes 2 sec for a passenger to get in or out. So the stop time of an elevator at a floor will be 2n, where n is the number of passengers getting in or out of the lift.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The elevators are assumed to have a single entry point for both exit and entry.\par}
\par
\par}
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Program Flow
\par}
{\tc\tcl2 \v Program Flow}
The program flow for the application is as follows:\par
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The {\b main.c} file calls the functions for static_simulation and in release 2 dynamc_simulation based on user input to run the alogorithm.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The static_simulation/dynamc_simulation function calls:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The function in {\b input_lifts.c} to get number of lifts from the user.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The function in {\b input_floors.c} to get number of floors from the user.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The function in {\b create_elevator_array.c} to create array for every elevator.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The function in {\b create_floor_array.c} to create array for every floor to hold waiting passeger.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The function in {\b count_passenger.c} to count the number of passenger in the input file.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The function in {\b read_passenger.c} to store the passenger details to passenger structure.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The function in {\b add_request_queue.c} to add passenger requests to a queue.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The function in {\b is_lift_on_floor.c} to check the lift status. If it is moving or not.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The function in {\b passengers_drop.c} to drop the passenger at the floor returning number of passengers dropped.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The function in {\b passengers_take_in.c} to take the passenger on floor based on maiximum count and space in elevator.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The function in {\b add_passenger_floor.c} to add passenger to the floor array.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The function in {\b remove_passenger_queue.c} to remove the passenger from request queue.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The function in {\b moving_lift_down.c} to change lift direction to down.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The function in {\b moving_lift_up.c} to change the lift direction to up.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The function in {\b average_waiting_time.c} to calculate the average and waiting time.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The function in {\b max_waiting_time.c} to calculate maximum waiting time.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The function in {\b is_lift_empty.c} to check the space in elevator\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The function in {\b remove_passenger_floor.c} to remove the passenger from the floor array. The dynamc_simulation also calls these functions:\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The function in {\b input_static_dynamic.c} to get whether user want static or dynamic simulation.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The function in {\b read_user_input_validate.c} to read and validate the inputs from user console for a passenger.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The function in {\b emergency_stop_handling.c} to to bring the lifts to nearest floor incase of emergency.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The function in {\b cli_update.c} to display elevator information on screen.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The function in {\b input_after_stop.c} to get input from user when emergency situation encountered.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The function in {\b travel_log_file.c} is used to write the two output files to the data folder travel_log.txt and waiting_times.txt.\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The program implements the SCAN algorithm. The elevators move in one direction until all requests along it path are completed or it reaches the end (top or ground floor). At which point it changes direction and waits for new requests before moving again in required direction.{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Down in case of at top floor.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Up in case of ground floor.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Any direction in all other cases.\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
All the elevators start at ground floor with direction of travel set to up.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The passenger array stores the data from input file. This data is then added to passenger_queue when the time of arrival of the passenger = the time of the simulation. This is done at very start of the main while loop in static_simulation and dynamic simulation function.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
This is followed by checking if passenger need to get on of off the elevator at the floor the elevator is currently at.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The passenger_queue is then traversed to check if any passengers in the queue can have their requests processed. Those passed are removed from queue and added to the proper entry in floor_array. Which is an array of passenger pointers.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The elevator timer is then checked and decremened if it greater than 0. If it is equal to 0. We check if passengers need to get off or do we need to change the floor of the elevator. In case of changing floor +3 seconds are added to the elevator timer.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The program continues until the iterator reaches predifined values. After which the average and max time are written to the files and the program exits. \par}
\par
\par}
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Documentation
\par}
{\tc\tcl2 \v Documentation}
Complete documentation of the source code can be found {\f2 here}. \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Introduction{\tc \v Introduction}\par \pard\plain 
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Elevator_Simulation is a software that operates any number of elevator in a commercial building with given number of floors.\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Installation
\par}
{\tc\tcl2 \v Installation}
Please refer to INSTALL.md file for installation instructions.\par}
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Usage
\par}
{\tc\tcl2 \v Usage}
The user needs to provide the software with a text file containing the passenger request detail for the elevator. The text file is named input.txt and must be placed in the "data" folder. The relative path is data/input.txt. The maximum number of floors in this file should correspond to what the user enters later in the program.\par
To start the program in windows either click on elevator.exe or type elevator.exe in command line. For cygwin/unix type ./elevator to start execution.\par
The program will ask for the following parameters at the execution of Elevator_Simulation:\par
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Static or Dynamic version : Press 0 to select Static Version or 1 to select Dynaic version. (Only for realease 2 version of program.)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Number of lifts : Specifies the number lifts in the building should be in the range of 1 to 100.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Number of elevators: Specifies the number elevators in the building should be in thr range of 1 to 100.(10 for dynamic simulation.)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Input file should be placed in the right path.Change the input file if needed. In the data/ folder\par}
\par
In case of Dynamic version the program only simulates until 1999 iterations. This is due to limitations of console windows,causing the program to slow down due to printing of cli_update. There are additional inputs the user can give to the program after every 30th or 200th iteration.\par
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Add Passenger request : If needed the user can enter details of a passenger to the program. That will be added to the queue.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Provide emergency stop in which the elevator will stop at next floor and remove all passengers. The user can then quit or continue the simulation.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Enable realtime mode. In which each iteration is 1 second long and the program asks for input after every 30th iterations.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Do not ask for input again and disable the realtime mode. So that the program can run without interuptions until completion.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Exit the simulation.\par}
\par
Please note that the binary is located in project {\f2 root}  folder. To start open terminal and type in root directory:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ./elevator\par
}
\par
for windows\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid elevator.exe\par
}
\par}
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Testing
\par}
{\tc\tcl2 \v Testing}
Unit testing is done for each functions defined in the software. The test cases can be run using the command below:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ./tests\par
}
\par
for windows\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid tests.exe\par
}
\par
Note: You must have compiled the tests.exe program as well.\par}
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Output Generation
\par}
{\tc\tcl2 \v Output Generation}
Output files travel_log.txt and waiting_times.txt will be generated and placed in {\f2 /data} folder.\par
travel_log.txt - File that gives Passenger*ID,Elevator_ID,Passenger_In time,Passenger* Entry floor,Passenger*Out time,Passenger* Exit floor\par
waiting_times.txt - File that gives Average waiting time of Passengers and Maximum waiting time of a Passenger. \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Installation{\tc \v Installation}\par \pard\plain 
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Supported Platforms:
\par}
{\tc\tcl2 \v Supported Platforms:}
Unix, Cygwin and MacOS.\par}
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Prerequisite
\par}
{\tc\tcl2 \v Prerequisite}
GCC Compiler, GNU make. mingw for windows.\par}
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
No Dependent External Libraries
\par}
{\tc\tcl2 \v No Dependent External Libraries}
\par}
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Build Project:
\par}
{\tc\tcl2 \v Build Project:}
Running make will compile elevator and tests programs. The test program will provide options to test the program functions. In case of error please find solution at end of document.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid make\par
}
\par
If you just want the elevator program. run:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid make elevator\par
}
\par
If you just want the tests program. run:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid make tests\par
}
\par
Excutable binaries "elevator.exe" and "tests.exe"(in windows) files will be placed in root folder of the project. For cygwin/unix type. {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ./elevator\par
}
\par
or {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ./tests\par
}
\par
In some cases the compilation may fail with the error: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Undefined Reference to WinMain\par
}
\par
or similar, in such cases, run {\f2 make}  command again or compile just the binary you want {\f2 make elevator}  or {\f2 make tests}  This program will compile in second attempt. \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Elevator_Simulator{\tc \v Elevator_Simulator}\par \pard\plain 
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Elevator_Simulator is a software that simulates Elevators in a commercial building.\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Authors
\par}
{\tc\tcl2 \v Authors}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Hariprasad Munusamy - Carleton University\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Maaz Jamal - Carleton University\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Ritika Arora - Carleton University\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Divyalakshmi Padmanaban - Ottawa University\par}
\par
\par}
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Installation
\par}
{\tc\tcl2 \v Installation}
Installation steps are mentioned in {\b INSTALL.md}\par}
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Usage
\par}
{\tc\tcl2 \v Usage}
To run, you must first compile the repository. Follow the instructions in {\b INSTALL.md}.Then you can follow instructions mentioned in {\b User_Manual.md}.\par}
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File Structure
\par}
{\tc\tcl2 \v File Structure}
The correct file structure\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 INSTALL.md  -> Installation Guide\par
\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 LICENSE     -> License file\par
\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 Makefile    -> Makefile\par
\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 README.md   -> Readme file\par
\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 doc\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 html    -> Doxygen documentation\par
\'E2\'94\'82   \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 latex   -> Doxygen documentation in latex\par
\'E2\'94\'82   \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 man     -> Doxygen documentation in man\par
\'E2\'94\'82   \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 rtf     -> Doxygen documentation in rtf \par
\'E2\'94\'82   \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 xml     -> Doxygen documentation in xml \par
\'E2\'94\'82   \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 Developer_Manual.md -> Developer Manual\par
\'E2\'94\'82   \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 Doxyfile -> Doxygen configuration file\par
\'E2\'94\'82   \'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 User_Manual.md      -> User Manual\par
\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 include     -> Header files\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 input_static_dynamic.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 input_floors.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 input_lifts.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 count_passenger.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 read_passenger.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 moving_lift_up.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 moving_lift_down.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 input_after_stop.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 is_lift_empty.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 is_lift_on_floor.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 passengers_take_in.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 passengers_drop.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 read_user_input_validate.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 create_elevator_array.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 add_request_queue.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 add_passenger_floor.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 create_floor_array.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 add_passenger_floor.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 remove_passenger_floor.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 remove_passenger_queue.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 emergency_stop _handling.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 average_maximum waiting_time.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 travel_log_file.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 cli_update.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 static_simulation.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 dynamic_simulation.h\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 simulations.h\par
\'E2\'94\'82   \'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 structures.h\par
\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 obj     -> Object files\par
\'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 src     -> Source files for elevator_simulator\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 input_static_dynamic.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 input_floors.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 input_lifts.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 count_passenger.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 read_passenger.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 moving_lift_up.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 moving_lift_down.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 input_after_stop.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 is_lift_empty.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 is_lift_on_floor.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 passengers_take_in.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 passengers_drop.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 read_user_input_validate.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 create_elevator_array.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 add_request_queue.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 add_passenger_floor.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 create_floor_array.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 add_passenger_floor.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 remove_passenger_floor.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 remove_passenger_queue.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 emergency_stop _handling.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 average_maximum waiting_time.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 travel_log_file.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 static_simulation.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 dynamic_simulation.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 max_waiting_time.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 main.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 globals.c\par
\'E2\'94\'82\'C2\'A0\'C2\'A0 \'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 cli_update.c\par
\'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 test\par
    \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 test_main.c -> Main function for testing\par
    \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 test_cases.c\par
    \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 test_remove_passenger_queue.c\par
    \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 test_read_passenger.c\par
    \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 test_passenger_take_in.c\par
    \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 test_max_waiting_time.c\par
    \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 test_is_lift_on_floor.c\par
    \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 test_lift_empty.c\par
    \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 test_input_floors.c\par
    \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 test_input_after_stop.c\par
    \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 test_create_floor_array.c\par
    \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 test_count_passenger.c\par
    \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 test_add_request_queue.c\par
    \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 test_average_waiting_time.c\par
    \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 test_input_lifts.c\par
    \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 test_moving_lift_down.c\par
    \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 include     -> Header file for test function\par
    \'E2\'94\'82   \'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 test_functions.h\par
    \'E2\'94\'9C\'E2\'94\'80\'E2\'94\'80 data -> Contains text file inputs for user tests\par
    \'E2\'94\'94\'E2\'94\'80\'E2\'94\'80 results -> Contains the txt file logs of the results.\par
}
\par}
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
For Developers
\par}
{\tc\tcl2 \v For Developers}
The developer manual is available {\b here}.\par}
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
License
\par}
{\tc\tcl2 \v License}
This project is licensed under the GPL 2.0 License - see the LICENSE.md file for details\par}
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Acknowledgements
\par}
{\tc\tcl2 \v Acknowledgements}
Thank to Dr. Cristina Ruiz Martin for providing guidance on how to develop the software. \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b elevator} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure to store important information about an elevator })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAID \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b passenger} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure to store important information about a passenger })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all documented files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b add_passenger_floor.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add passengers to the floor array })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b add_request_queue.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declarations for add_request_queue function. Used to add passenger to queue })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b average_waiting_time.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has the declaration for the average_waiting_time function @detail The function has one input parameter: time_difference which is the difference between the time passenger arrived and the time he got into the elevator })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b cli_update.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declarations for cli_update function. Used to update the command line interface of the function })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b count_passenger.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Counts the number of passengers from the input file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b create_elevator_array.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declaration for create_elevator_array function -creates an array for elevators with respective to input entered by user })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b create_floor_array.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declaration for create_floor_array function -creates an array for floors with respective to input entered by user })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b dynamic_functions.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simply imports all the headers of the different of dynamic function })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b dynamic_simulation.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains the declaration of the function {\b dynamic_simulation()} This function runs the dynamic mode of the project })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b emergency_stop_handling.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declaration for the emergency_stop_handling() function })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b functions.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simply contains all the headers of the different function })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b globals.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declarations for globals elevator_count, passenger_count and floor_count })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b input_after_stop.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the user input to determine status of simulation after encountering emergency stop })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b input_floors.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Obtains the floor count-Total number of floors in the building })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b input_lifts.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declaration for the {\b input_lifts()} function })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b input_static_dynamic.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has the declaration for input_static_dynamic function })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b is_lift_empty.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has the declaration for the is_lift_empty function @detail The function has two input parameters: one is an array of elevators of elevator type @detail and the other is the index of the array which can be used as the number of the elevator })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b is_lift_on_floor.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains declaration for is_lift_on_floor function -Reads the elevator structure's attribute moving_floor })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b max_waiting_time.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has the declaration for the max_waiting_time function @detail The function has one input parameter: time_difference which is the difference between the time passenger arrived and the time he got into the elevator })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b moving_lift_down.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declaration for moving_lift_down function that changes the direction of lift. the function is defination found in {\b moving_lift_down.c} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b moving_lift_up.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has the declaration for moving_lift_up function @detail The function has two input parameters: one is an array of elevators elevator_arr of elevator type and the other is the index of the array which can be used as the number of the elevator })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b passengers_drop.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Drops the passeger in corresponding floor })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b passengers_take_in.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declarations for passenger_take_in function. Used to add passenger to the provided elevator array entry })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b read_passenger.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the input file for passenger id,arrival time,starting floor and destination floor })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b read_user_input_validate.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declarations for read_user_input_validate function. Reads the passenger information from the user console and adds it to the passenger structure after validating })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b remove_passenger_floor.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declaration for the remove_passenger_floor })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b remove_passenger_queue.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declaration for remove_passenger_queue function that remoove passenger from a queue })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b simulations.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file simply includes the header files of the two simulations })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b static_simulation.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains the declaration of the function static_simulation The function carries out the static simulation of the project })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b structures.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declarations for structure passenger, elevator to be used in the program })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/include/{\b travel_log_file.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function declaration for {\b travel_log_file()} function which writes the travel history of passenger in the lift })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b add_passenger_floor.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the definition for add_passenger_floor file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b add_request_queue.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Definition of add_request_queue })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b average_waiting_time.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the average waiting time for the passengers })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b cli_update.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declaration for cli_update function. Which displays elevator information })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b count_passenger.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads line by line and counts the number of passenger based on passenger ID. When passenger ID equal to "911" it is considered as Emergency stop and wont be counted towards the passenger_count })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b create_elevator_array.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The function creates array for each elevator })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b create_floor_array.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The function create arrays for every floor })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b dynamic_simulation.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains the definition of dynamic_simulation The function contains the algorithm for dynamic release of the program })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b emergency_stop_handling.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
On account of emergency stop condition,All the elevators re moved to nearest floor. Passengers are removed from the elevators })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b globals.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the global variables used in the program })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b input_after_stop.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When the simulation encounters a emergency stop situation input_after_stop function is invoked prompting for the user input })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b input_floors.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Obtains the floor count-Total number of floors in the building.Enables the user to enter the total number of floors in the building. based on availability. If none of those symptoms then patient is not admitted })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b input_lifts.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Definition of input_lifts })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b input_static_dynamic.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prompts user for type of simulation they want to run })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b is_lift_empty.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if there is any space in the elevator to add more passengers })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b is_lift_on_floor.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the elevator structure's attribute between_floors })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b main.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function executes the Static and Dynamic version of elevator })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b max_waiting_time.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the maximum waiting time for the passengers })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b moving_lift_down.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Definition of moving_lift_down })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b moving_lift_up.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To set the direction of the lift to Upward direction })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b passengers_drop.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The function takes in the elevator_array })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b passengers_take_in.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Definition of passengers_take_in })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b read_passenger.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the input file for passenger id,arrival time,starting floor and destination floor. Enables to read the data from file and store in a structure of maximum capacity 100 })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b read_user_input_validate.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the input from the console and adds to the passenger struct after validating })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b remove_passenger_floor.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the passenger details from floor specified })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b remove_passenger_queue.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Definition of {\b remove_passenger_queue()}. This function is removes a passenger from the passenger_queue })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b static_simulation.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains the definition of static_simulation The function contains the algorithm for static release of the program })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/src/{\b travel_log_file.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the deifintion of {\b travel_log_file()} this function writes useful logs about the travel of the passengers })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/test/{\b test_add_passenger_floor.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Blackbox unit testing for add_passenenger_floor function })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/test/{\b test_add_request_queue.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains function test_add_request_queue() that provides unit testing for function {\b add_request_queue()} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/test/{\b test_average_waiting_time.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests the average_waiting_time function if working fine or not })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/test/{\b test_cases.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains all the tests and menue logic to choose each test })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/test/{\b test_cli_update.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test case for {\b cli_update()} function })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/test/{\b test_count_passenger.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test function for count_passenger() })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/test/{\b test_create_elevator_array.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains test cases for {\b create_elevator_array()} function })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/test/{\b test_create_floor_array.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To test create_floor_array function which creates array for every floor })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/test/{\b test_input_after_stop.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When the simulation encounters a emergency stop situation input_after_stop function is invoked prompting for the user input })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/test/{\b test_input_floors.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test cases for testing the {\b input_floors()} function })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/test/{\b test_input_lifts.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains function test_input_lifts() that provides unit testing for function {\b input_lifts()} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/test/{\b test_is_lift_empty.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests if the is_lift_empty function works fine or not })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/test/{\b test_is_lift_on_floor.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test cases for the function {\b is_lift_on_floor()} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/test/{\b test_main.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Serves as an entry point for the test_cases functions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/test/{\b test_max_waiting_time.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests the max_waiting_time function if working fine or not })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/test/{\b test_moving_lift_down.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test cases for {\b moving_lift_down.c} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/test/{\b test_passenger_take_in.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains function test_passenger_take_in() that provides unit testing for function passenger_take_in() })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/test/{\b test_read_passenger.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests for {\b read_passenger()} function })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/test/{\b test_remove_passenger_floor.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests for remove_passenger_floor })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/test/{\b test_remove_passenger_queue.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains function test_remove_passenger_queue() that provides unit testing for function {\b remove_passenger_queue()} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/Work/git_repo/elevator_simulator/test/include/{\b test_functions.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function declarations for all the test_functions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
elevator Struct Reference\par \pard\plain 
{\tc\tcl2 \v elevator}
{\xe \v elevator}
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
structure to store important information about an elevator. }}\par
{
{\f2 #include <structures.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b moving}{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Is the elevator moving? True 1 or False(stationary) 0. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b between_floor}{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Is elevator between floors. True 1 between floors. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b direction_up}{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Is the elevator going up? True 1 for going up. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b direction_down}{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Is the elevator going down? True 1 for going down. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool * {\b stop_at_floor}{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
points to boolean array of floors and shows if the elevator will stop at a certain floor or not. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b passenger_count}{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
count of passenger occupying the elevator }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b max_passenger}{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maximum number of passengers the lift can accomodate. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b cur_floor}{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The current floor of the elevator. Floors start at 1. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b timer}{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time clock untill the next floor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b passenger} * {\b passenger_arr}{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
points to a array of struct pasenger of size max_passenger. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
structure to store important information about an elevator. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stores information about the elevator such as direction of travel, the floors to stop at. The maximum number of passengers the lift can accomodate and the current passengers in the lift and their information. and time it takes to go to the reach next floor. \par
}{
Definition at line 35 of file structures.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/{\b structures.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
passenger Struct Reference\par \pard\plain 
{\tc\tcl2 \v passenger}
{\xe \v passenger}
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
structure to store important information about a passenger. }}\par
{
{\f2 #include <structures.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b in_elevator}{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stores whether passegner is in elevator. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b arrival_time}{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
stores arrival time of the passenger }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b arrival_floor}{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
stores the arrival_floor of the passenger }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b dest_floor}{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
stores the destination floor of the passenger }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b id}{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
stores the passenger_id of the passenger }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b passenger} * {\b next}{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
stores address of the next node in case of creation of queues }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
structure to store important information about a passenger. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stores the arrival time and floor and destination floor of the passenger. as well as the passenger id. There is a next passenger pointer to create queues \par
}{
Definition at line 16 of file structures.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/{\b structures.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/Work/git_repo/elevator_simulator/test/{\b test_create_floor_array.c}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/add_passenger_floor.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/add_passenger_floor.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/add_passenger_floor.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add passengers to the floor array }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "structures.h"}\par
{\f2 #include "globals.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add_passenger_floor} (struct {\b passenger} *floor[], int index, struct {\b passenger} passenger_info)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a passenger to the floor. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add passengers to the floor array \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v add_passenger_floor\:add_passenger_floor.h}
{\xe \v add_passenger_floor.h\:add_passenger_floor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void add_passenger_floor (struct {\b passenger} *  {\i floor}[], int  {\i index}, struct {\b passenger}  {\i passenger_info})}}
\par
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a passenger to the floor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
@detail takes a floor array. The index of floor and passenger info. It then allocates a memory location and add the passenger to the passenger queue on that floor. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i floor} \cell }{an array of pointer of type struct passenger, Used to form passenger queue on each floor. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i index} \cell }{the index at to add the passenger. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i passenger_info} \cell }{struct passenger that contains the information about the passenger.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
void does not return anythin \par
}}}{
Definition at line 24 of file add_passenger_floor.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25 \{\par
26 \par
27     assert(index >= 0);\par
28     assert(index < floor_count);\par
29     {\cf17 static} {\cf18 int} no_of_passengers_added = 0;\par
30     {\cf17 struct }passenger *cur;\par
31     cur = floor[index];\par
32     {\cf19 if} (cur == NULL)\par
33     \{\par
34         {\cf17 struct }passenger *temp = ({\cf17 struct }passenger *)malloc({\cf17 sizeof}({\cf17 struct} passenger));\par
35         *temp = passenger_info;\par
36         floor[index] = temp;\par
37         floor[index]->next = NULL;\par
38         printf({\cf22 "passenger %d arrived at floor: %d. No of passengers Added: %d\\n"}, temp->id, index + 1, ++no_of_passengers_added);\par
39         {\cf19 return};\par
40     \}\par
41     {\cf19 while} (cur->next != NULL)\par
42     \{\par
43         cur = cur->next;\par
44     \}\par
45 \par
46     {\cf17 struct }passenger *temp = ({\cf17 struct }passenger *)malloc({\cf17 sizeof}({\cf17 struct} passenger));\par
47     *temp = passenger_info;\par
48     cur->next = temp;\par
49     temp->next = NULL;\par
50     printf({\cf22 "passenger %d arrived at floor: %d. No of passengers Added: %d\\n"}, temp->id, index + 1, ++no_of_passengers_added);\par
51     {\cf19 return};\par
52 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/add_request_queue.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/add_request_queue.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/add_request_queue.h}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains declarations for add_request_queue function. Used to add passenger to queue }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "structures.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b passenger} * {\b add_request_queue} (struct {\b passenger} *head, struct {\b passenger} passenger_queue)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a passenger struct to the passenger queue. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains declarations for add_request_queue function. Used to add passenger to queue \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v add_request_queue\:add_request_queue.h}
{\xe \v add_request_queue.h\:add_request_queue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b passenger}* add_request_queue (struct {\b passenger} *  {\i head}, struct {\b passenger}  {\i passenger_queue})}}
\par
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a passenger struct to the passenger queue. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a passenger to passenger queue. This function can be used to make queues for the requests from passengers from the file or on a floor. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i head} \cell }{is a pointer to the head of the queue \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i passenger_queue} \cell }{passenger struct containing data of the passenger. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
passenger* returns pointer to the updated head of queue if operation is fine. head ptr is unchanged if memory cannot be allocated. \par
}}}{
Definition at line 21 of file add_request_queue.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22 \{\par
23     {\cf17 struct }passenger *temp = ({\cf17 struct }passenger *)malloc({\cf17 sizeof}({\cf17 struct} passenger));\par
24     *temp = passenger_queue;\par
25     {\cf17 struct }passenger *cur = head;\par
26 \par
27     {\cf19 if} (temp == NULL)\par
28     \{\par
29         fprintf(stderr, {\cf22 "MEMORY ALLOCATION FAILED IN add_request_queue. \\n"});\par
30         fprintf(stderr, {\cf22 "SKIPPING ADDING PASSENGER TO QUEUE"});\par
31         {\cf19 return} head;\par
32     \}\par
33     {\cf19 if} (head == NULL)\par
34     \{\par
35         temp->next = NULL;\par
36         head = temp;\par
37         {\cf19 return} head;\par
38     \}\par
39 \par
40     {\cf19 while} (cur->next != NULL)\par
41     \{\par
42         cur = cur->next;\par
43     \}\par
44     cur->next = temp;\par
45     temp->next = NULL;\par
46     {\cf19 return} head;\par
47 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/average_waiting_time.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/average_waiting_time.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/average_waiting_time.h}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has the declaration for the average_waiting_time function @detail The function has one input parameter: time_difference which is the difference between the time passenger arrived and the time he got into the elevator. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "structures.h"}\par
{\f2 #include "globals.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

float {\b average_waiting_time} (float time_difference){\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has the declaration for the average_waiting_time function @detail The function has one input parameter: time_difference which is the difference between the time passenger arrived and the time he got into the elevator. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
float returns the average time taken by the passengers waiting to get into the elevator \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/cli_update.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/cli_update.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/cli_update.h}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains declarations for cli_update function. Used to update the command line interface of the function. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "structures.h"}\par
{\f2 #include "globals.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b cli_update} (struct {\b elevator} arr[], unsigned int loop_time)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Updates the command line interface with the elevator data. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains declarations for cli_update function. Used to update the command line interface of the function. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v cli_update\:cli_update.h}
{\xe \v cli_update.h\:cli_update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void cli_update (struct {\b elevator}  {\i arr}[], unsigned int  {\i loop_time})}}
\par
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Updates the command line interface with the elevator data. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears the screen and repopulates it with the updated elevator data. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i arr} \cell }{struct elevator that is an array of elevators. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
 \par
}}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if we are in unix/cygwin environment or windows environment\par
}{
Definition at line 19 of file cli_update.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20 \{\par
21 \par
24 {\cf21 #if __unix__ || __CYGWIN__}\par
25     system({\cf22 "clear"});\par
26 {\cf21 #elif _WIN32}\par
27     system({\cf22 "cls"});\par
28 {\cf21 #endif}\par
29     puts({\cf22 "Elevator\\tTime\\tFloor\\tPassengers\\tDirection\\tMoving\\t"});\par
30     {\cf18 int} current_floor = 0;\par
31     {\cf18 int} passenger = 0;\par
32     {\cf18 bool} direction_down = {\cf17 false};\par
33     {\cf18 bool} direction_up = {\cf17 false};\par
34     {\cf18 int} next_floor_time = 0;\par
35     {\cf18 bool} moving = {\cf17 false};\par
36     {\cf18 char} direction[5] = \{{\cf23 '\\0'},{\cf23 '\\0'},{\cf23 '\\0'},{\cf23 '\\0'},{\cf23 '\\0'}\};\par
37     {\cf18 char} move_or_no[4] = \{{\cf23 '\\0'},{\cf23 '\\0'},{\cf23 '\\0'},{\cf23 '\\0'},\};\par
38     {\cf19 for} ({\cf18 int} i = 0; i < elevator_count; i++)\par
39     \{\par
40         current_floor = arr[i].cur_floor;\par
41         passenger = arr[i].passenger_count;\par
42         direction_down = arr[i].direction_down;\par
43         direction_up = arr[i].direction_up;\par
44         next_floor_time = arr[i].timer;\par
45         moving = arr[i].moving;\par
46         {\cf19 if} (direction_up && direction_down)\par
47         \{\par
48             strcpy(direction, {\cf22 "ANY"});\par
49         \}\par
50         {\cf19 else} {\cf19 if} (direction_up)\par
51         \{\par
52             strcpy(direction, {\cf22 "UP"});\par
53         \}\par
54         {\cf19 else}\par
55         \{\par
56             strcpy(direction, {\cf22 "DOWN"});\par
57         \}\par
58         {\cf19 if} (moving)\par
59         \{\par
60             strcpy(move_or_no, {\cf22 "YES"});\par
61         \}\par
62         {\cf19 else}\par
63         \{\par
64             strcpy(move_or_no, {\cf22 "NO"});\par
65         \}\par
66         printf({\cf22 "%d\\t\\t%d\\t%d\\t%d\\t\\t%s\\t\\t%s\\n"}, i, next_floor_time, current_floor, passenger, direction, move_or_no);\par
67     \}\par
68     printf({\cf22 "SIMULATION TIME: %d\\n"},loop_time);\par
69 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/count_passenger.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/count_passenger.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/count_passenger.h}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Counts the number of passengers from the input file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "structures.h"}\par
{\f2 #include "globals.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b count_passenger} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Counts the number of passengers from the input file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v count_passenger\:count_passenger.h}
{\xe \v count_passenger.h\:count_passenger}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int count_passenger ()}}
\par
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Counts the passenger requests\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i No} \cell }{input parameter. The function uses the input file\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Returns count on successful execution and 0 if file doesn't exist. \par
}}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
es to store the number of emergency stop situations\par
}{
Definition at line 23 of file count_passenger.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24 \{\par
26     {\cf18 int} es=0;\par
27     passenger_count=0; {\cf20 //global variable stores the passenger count}\par
28     FILE *f;\par
29     {\cf18 char} a[10];\par
30     f=fopen({\cf22 "data/input.txt"},{\cf22 "r"});\par
31     {\cf19 if} (f==NULL) \par
32     \{ \par
33         printf({\cf22 "no input file exists"}); \par
34         {\cf19 return} 0; \par
35     \}\par
36     {\cf19 while}(fscanf(f,{\cf22 "%s"},a)!=EOF)\par
37     \{\par
38         {\cf19 if}((passenger_count==0)||(passenger_count%4)==0)\par
39         \{\par
40             {\cf19 if}(atoi(a)==911)\par
41             \{\par
42             es++;\par
43             \}\par
44         \}\par
45         passenger_count++;\par
46     \}\par
47     fclose(f);\par
48     passenger_count=passenger_count/4;\par
49     passenger_count=passenger_count-es;\par
50     {\cf19 return} passenger_count;  {\cf20 //returns the passenger count}\par
51 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/create_elevator_array.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/create_elevator_array.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/create_elevator_array.h}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
declaration for create_elevator_array function -creates an array for elevators with respective to input entered by user. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "structures.h"}\par
{\f2 #include "globals.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b elevator} * {\b create_elevator_array} (int no_of_elevators)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
declaration for create_elevator_array function -creates an array for elevators with respective to input entered by user. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_elevator_array\:create_elevator_array.h}
{\xe \v create_elevator_array.h\:create_elevator_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b elevator}* create_elevator_array (int  {\i no_of_elevators})}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constraints checks the input parameter-no of elevators . No of elevators should be in range(1-100). Prints error message if the no of elevators is out of range and if memory allocation fails. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i The} \cell }{function takes number of lifts as input. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Returns the array of elevators. \par
}}}{
Definition at line 23 of file create_elevator_array.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24 \{\par
25     \par
26     {\cf19 if}((no_of_elevators==0)||(no_of_elevators>100)||(no_of_elevators<1)){\cf20 //checks if the input parameter is valid.}\par
27     \{\par
28         printf({\cf22 "Input parameter -Number of elevators entered is invalid \\n"});\par
29         {\cf19 return} 0;\par
30     \}\par
31     {\cf17 struct }elevator *ele;\par
32     ele=malloc (no_of_elevators * {\cf17 sizeof}({\cf17 struct} elevator));{\cf20 //creates memory for the input-no_of_elevators.}\par
33     {\cf19 if}(ele==NULL){\cf20 //checks if the memory allocation is success}\par
34     \{\par
35         printf({\cf22 "Memory allocation failed \\n"});\par
36         {\cf19 return} 0;\par
37     \}\par
38     {\cf19 else}\par
39     \{\par
40         \par
41         {\cf18 int} i;\par
42         {\cf18 int} j;\par
43         {\cf18 int} k;\par
44         {\cf19 for}(i=0;i<no_of_elevators;i++){\cf20 //initialising the array elements}\par
45         \{\par
46             ele[i].moving=0;\par
47             ele[i].between_floor=0;\par
48             ele[i].direction_up={\cf17 true};\par
49             ele[i].direction_down={\cf17 false};\par
50             ele[i].stop_at_floor=malloc(floor_count*{\cf17 sizeof}({\cf18 bool}));\par
51             {\cf19 for}(k=0;k<floor_count;k++)\par
52             \{\par
53                 ele[i].stop_at_floor[k]=0;\par
54             \}\par
55             ele[i].passenger_count=0;\par
56             ele[i].max_passenger=10;\par
57             ele[i].cur_floor=1;\par
58             ele[i].timer=0;\par
59             ele[i].passenger_arr = malloc(ele[i].max_passenger*{\cf17 sizeof}({\cf17 struct} passenger));\par
60             {\cf19 for} (j=0;j<ele[i].max_passenger;j++)\par
61             \{\par
62             ele[i].passenger_arr[j].in_elevator=0;\par
63             ele[i].passenger_arr[j].arrival_time=0;\par
64             ele[i].passenger_arr[j].arrival_floor=0;\par
65             ele[i].passenger_arr[j].dest_floor=0;\par
66             ele[i].passenger_arr[j].id=0;\par
67             \}\par
68             \par
69         \}\par
70     \par
71     {\cf19 return} ele;\par
72     \}\par
73     \par
74 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/create_floor_array.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/create_floor_array.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/create_floor_array.h}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
declaration for create_floor_array function -creates an array for floors with respective to input entered by user. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "structures.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b passenger} ** {\b create_floor_array} (int no_of_floors)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
declaration for create_floor_array function -creates an array for floors with respective to input entered by user. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_floor_array\:create_floor_array.h}
{\xe \v create_floor_array.h\:create_floor_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b passenger}** create_floor_array (int  {\i no_of_floors})}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates array for every floor to store the passenger with requests.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i Gets} \cell }{the number of floors as input and creates a list of array for every floor.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
structure of arrays for the given number of floors. \par
}}}{
Definition at line 24 of file create_floor_array.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25  \{\par
26     {\cf19 if}(no_of_floors>floor_count)\par
27     \{\par
28         {\cf19 return} 0;\par
29     \}\par
30     {\cf17 struct }passenger **fla;\par
31     fla=({\cf17 struct }passenger **) calloc (no_of_floors,{\cf17 sizeof}({\cf17 struct} passenger*));\par
32     {\cf19 if}(fla==NULL)\par
33     \{\par
34         {\cf19 return} 0;\par
35     \}\par
36     {\cf19 else}\par
37     \{\par
38 \par
39     {\cf19 return} fla; {\cf20 //returns the pointer to a structure of array}\par
40     \}\par
41 \par
42 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/dynamic_functions.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/dynamic_functions.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/dynamic_functions.h}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simply imports all the headers of the different of dynamic function. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "cli_update.h"}\par
{\f2 #include "input_after_stop.h"}\par
{\f2 #include "input_static_dynamic.h"}\par
{\f2 #include "emergency_stop_handling.h"}\par
{\f2 #include "read_user_input_validate.h"}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simply imports all the headers of the different of dynamic function. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
 \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/dynamic_simulation.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/dynamic_simulation.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/dynamic_simulation.h}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
this file contains the declaration of the function {\b dynamic_simulation()} This function runs the dynamic mode of the project. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "functions.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b dynamic_simulation} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function contains the working logic of the elevator array function for dynamic release. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
this file contains the declaration of the function {\b dynamic_simulation()} This function runs the dynamic mode of the project. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v dynamic_simulation\:dynamic_simulation.h}
{\xe \v dynamic_simulation.h\:dynamic_simulation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int dynamic_simulation (void )}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function contains the working logic of the elevator array function for dynamic release. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
@detail Contains the logic for the dynamic version. It contains the main logic loop for travel of elevators .The loop for placing passengers on floors and the complete flow of the program. Plus additional functional calls for the dynamic release.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
return 1 for successful completion. \par
}}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A boolean array that shows if elevator needs to stop at a floor. to pick a passenger.\par
Array conatining Elevators\par
Array to pointer of type passenger. Stores passengers on floors.\par
stores the passengers from input file.\par
main time counter\par
A queue of request made by passengers\par
}{
Definition at line 25 of file dynamic_simulation.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26 \{\par
27 \par
28     elevator_count = -1;\par
29     {\cf19 while} (elevator_count == -1)\par
30     \{\par
31         elevator_count = input_lifts(1);\par
32     \}\par
33     floor_count = -1;\par
34 \par
35     {\cf19 while} (floor_count == -1)\par
36     \{\par
37         floor_count = input_floors();\par
38     \}\par
39     {\cf18 bool} *stop_at_floor_global = ({\cf18 bool} *)calloc(floor_count, {\cf17 sizeof}({\cf18 bool})); \par
40     {\cf17 struct }elevator *elevator_arr = create_elevator_array(elevator_count);  \par
41     {\cf17 struct }passenger **floor_array = create_floor_array(floor_count);       \par
42     passenger_count = count_passenger();\par
43     {\cf17 struct }passenger *passenger_array = ({\cf17 struct }passenger *)calloc(passenger_count, {\cf17 sizeof}({\cf17 struct} passenger)); \par
44     read_passenger(passenger_array);\par
45     {\cf18 unsigned} {\cf18 int} t = 0;                       \par
46     {\cf17 struct }passenger *passenger_queue = NULL; \par
47 \par
48     {\cf18 int} prev_time_index = 0;\par
49 \par
50     {\cf18 bool} enable_realtime = {\cf17 false};  {\cf20 // Realtime or full-speed;}\par
51     {\cf18 bool} enable_user_input = {\cf17 true}; {\cf20 // ask user for input or not;}\par
52     {\cf18 bool} exit_main_loop = {\cf17 false};   {\cf20 // should we exit main loop if user orders simulation stop}\par
53     time_t start_time;\par
54     time_t end_time;\par
55     {\cf18 int} time_difference = 0;\par
56     {\cf18 int} divisor = 200;\par
57     {\cf19 while} (t < 2000) {\cf20 //86400 for whole day. Setting to 2000 since cli_update slows the program down.}\par
58     \{\par
59 \par
60         {\cf19 if} (t % divisor == 0 && enable_user_input)\par
61         \{                                                         {\cf20 //choices}\par
62             {\cf17 struct }passenger temp_passenger = \{0, 0, 0, 0, 0, 0\}; {\cf20 //To store the user entered passenger}\par
63             {\cf18 int} stop_input = 0;\par
64             {\cf18 bool} incorrect_choice = {\cf17 true};\par
65             {\cf19 while} (incorrect_choice)\par
66             \{\par
67                 puts({\cf22 "CHOSE AMONG THE FOLLOWING CHOICES:"});\par
68                 puts({\cf22 "Note this is repeated after every approximately 30 seconds in realtime mode"});\par
69                 puts({\cf22 "and 200 iterations in non-realtime mode. Simulation starts in non-realtime mode."});\par
70                 puts({\cf22 "1- Enter A Passenger Details."});\par
71                 puts({\cf22 "2- Create an Emergency stop."});\par
72                 puts({\cf22 "3- Enable/Disable realtime timer. "});\par
73                 puts({\cf22 "4- Do not ask for input again & Disable realtime timer."});\par
74                 puts({\cf22 "5- Do Nothing and continue."});\par
75                 puts({\cf22 "6- Exit the simulation."});\par
76                 {\cf18 int} user_choice = 0;\par
77                 {\cf19 while} (scanf({\cf22 "%d"}, &user_choice) == 0)\par
78                 \{\par
79                     puts({\cf22 "Incorrect Choice Please Try Again."});\par
80                     scanf({\cf22 "%*[\\n]"}); {\cf20 //discard all inputs until newline character}\par
81                 \}\par
82                 {\cf19 if} (user_choice > 0 && user_choice < 7)\par
83                 \{\par
84                     incorrect_choice = {\cf17 false}; {\cf20 //made correct choice no exit selection loop.}\par
85                     {\cf19 switch} (user_choice)\par
86                     \{\par
87 \par
88                     {\cf20 //1- Enter A Passenger Details.}\par
89                     {\cf19 case} 1:\par
90                         read_user_input_validate(&temp_passenger, t);\par
91                         passenger_queue = add_request_queue(passenger_queue, temp_passenger);\par
92                         {\cf19 break};\par
93                     {\cf20 //2- Create an Emergency stop.}\par
94                     {\cf19 case} 2:\par
95                         emergency_stop_handling(elevator_arr, &t);\par
96                         {\cf19 while} ((stop_input = input_after_stop()) == -1)\par
97                         \{ {\cf20 //loop until we get right input}\par
98                         \};\par
99                         {\cf19 if} (stop_input == 0)\par
100                         \{\par
101                             exit_main_loop = {\cf17 true};\par
102                         \}\par
103                         {\cf19 break};\par
104                     {\cf19 case} 3:\par
105                         enable_realtime = !enable_realtime; {\cf20 //toggle}\par
106                         {\cf19 if} (enable_realtime)\par
107                         \{\par
108                             divisor = 30;\par
109                         \}\par
110                         {\cf19 else}\par
111                         \{\par
112                             divisor = 200;\par
113                         \}\par
114                         printf({\cf22 "Set Real-time to : %d\\n"}, enable_realtime);\par
115                         {\cf19 break};\par
116                     {\cf19 case} 4:\par
117                         enable_realtime = {\cf17 false};\par
118                         enable_user_input = {\cf17 false};\par
119                         exit_main_loop = {\cf17 false};\par
120                         {\cf19 break};\par
121                     {\cf19 case} 5:\par
122                         {\cf19 break};\par
123                     {\cf19 case} 6:\par
124                         exit_main_loop = {\cf17 true};\par
125                         {\cf19 break};\par
126                     \}\par
127                 \}\par
128             \}\par
129             {\cf19 if} (exit_main_loop)\par
130             \{ {\cf20 //exit main loop;}\par
131                 {\cf19 break};\par
132             \}\par
133         \}\par
134         {\cf20 //set start time}\par
135         start_time = time(NULL);\par
136         {\cf20 //update the cli}\par
137         cli_update(elevator_arr, t);\par
138 \par
139         {\cf20 // Add passenger with current time step to queue}\par
140         {\cf19 for} ({\cf18 int} i_pass = prev_time_index; i_pass < passenger_count; i_pass++) {\cf20 //debugged works perfectly}\par
141         \{\par
142             {\cf19 if} (passenger_array[i_pass].arrival_time < t) {\cf20 //due to emergency stop we can skip some entries}\par
143             \{\par
144                 {\cf19 while} (passenger_array[prev_time_index].arrival_time < t && prev_time_index < passenger_count)\par
145                 \{\par
146                     prev_time_index++; {\cf20 //increment until we reach passenger with current or greater arrival_time then  t or reach end array.}\par
147                 \}\par
148             \}\par
149 \par
150             {\cf20 //Assume the passenger_array is sorted by arrival time.}\par
151             {\cf20 //prev_time_index prevents us from starting at previous index}\par
152             {\cf19 if} (passenger_array[i_pass].arrival_time == t)\par
153             \{\par
154 \par
155                 passenger_queue = add_request_queue(passenger_queue, passenger_array[i_pass]);\par
156                 prev_time_index++;\par
157             \}\par
158             {\cf19 else}\par
159             \{\par
160                 {\cf19 break};\par
161             \}\par
162         \}\par
163 \par
164         {\cf19 for} ({\cf18 int} i = 0; i < elevator_count; i++)\par
165         \{\par
166 \par
167             {\cf19 if} (is_lift_on_floor(elevator_arr, i))\par
168             \{\par
169                 {\cf18 int} drop_delay = 0;\par
170                 {\cf18 int} add_delay = 0;\par
171                 {\cf18 int} stop_change = elevator_arr[i].cur_floor - 1;\par
172                 {\cf19 if} (elevator_arr[i].passenger_count > 0)\par
173                 \{\par
174                     {\cf19 if} (elevator_arr[i].stop_at_floor[stop_change])\par
175                     \{ {\cf20 //remove any passengers that need to get off}\par
176                         drop_delay = passengers_drop(elevator_arr, i, elevator_arr[i].cur_floor, t);\par
177 \par
178                         {\cf19 if} (drop_delay > 0 || elevator_arr[i].passenger_count >= elevator_arr[i].max_passenger) {\cf20 //dropped passengers here or lift full}\par
179                         \{\par
180                             elevator_arr[i].stop_at_floor[stop_change] = {\cf17 false}; {\cf20 //dropped passengers here}\par
181                         \}\par
182                     \}\par
183                 \}\par
184                 {\cf19 if} (elevator_arr[i].passenger_count < elevator_arr[i].max_passenger)\par
185                 \{\par
186 \par
187                     add_delay = passengers_take_in(elevator_arr, i, floor_array, elevator_arr[i].cur_floor, t);\par
188                     elevator_arr[i].stop_at_floor[stop_change] = {\cf17 false};\par
189                     {\cf19 if} (floor_array[stop_change] == NULL)\par
190                     \{\par
191                         stop_at_floor_global[stop_change] = {\cf17 false};\par
192                     \}\par
193                     {\cf19 else}\par
194                     \{ {\cf20 //happens in case the lift gets full and their are still passengers on floor.}\par
195                         stop_at_floor_global[stop_change] = {\cf17 true};\par
196                     \}\par
197                     elevator_arr[i].stop_at_floor[stop_change] = {\cf17 false}; {\cf20 //lift has taken in or dropped passengers or is full and has completed it purpose on floor so we set to false.}\par
198                 \}\par
199                 {\cf18 int} total_delay = 2 * drop_delay + 2 * add_delay;\par
200                 elevator_arr[i].timer += total_delay;\par
201             \}\par
202 \par
203             {\cf17 struct }passenger *cur = passenger_queue;\par
204             {\cf18 int} index = 0;\par
205             {\cf19 while} (cur != NULL)\par
206             \{ {\cf20 //iterating over passenger queue}\par
207 \par
208                 {\cf18 bool} direction_up = (cur->arrival_floor <= cur->dest_floor); {\cf20 //passenger direction up}\par
209                 {\cf18 bool} direction_down = (cur->arrival_floor >= cur->dest_floor);\par
210                 {\cf19 if} (elevator_arr[i].direction_up == direction_up || elevator_arr[i].direction_down == direction_down)\par
211                 \{\par
212                     {\cf18 bool} is_above = cur->arrival_floor >= elevator_arr[i].cur_floor;\par
213                     {\cf18 bool} is_below = cur->arrival_floor <= elevator_arr[i].cur_floor;\par
214                     {\cf19 if} (elevator_arr[i].direction_up == is_above || elevator_arr[i].direction_down == is_below)\par
215                     \{ {\cf20 //elevator can pick this person up}\par
216                         {\cf17 struct }passenger temp = *cur;\par
217                         temp.next = NULL;                                 {\cf20 // removing this from passenger queue list}\par
218                         {\cf18 int} arrival_floor_index = temp.arrival_floor - 1; {\cf20 //-1 because of mismatch between array and input file}\par
219 \par
220                         add_passenger_floor(floor_array, arrival_floor_index, temp);\par
221                         stop_at_floor_global[temp.arrival_floor - 1] = {\cf17 true};\par
222                         passenger_queue = remove_passenger_queue(index, passenger_queue);\par
223                         index--; {\cf20 //list is smaller by one node.}\par
224                     \}\par
225                 \}\par
226 \par
227                 {\cf19 else}\par
228                 \{\par
229                     {\cf20 //is elevator at top floor}\par
230                     {\cf19 if} (elevator_arr[i].cur_floor == floor_count)\par
231                     \{\par
232                         {\cf20 //change direction to move down}\par
233                         {\cf18 int} success = moving_lift_down(elevator_arr, i);\par
234                         {\cf19 if} (success == -1)\par
235                         \{\par
236                             fprintf(stderr, {\cf22 "Could not change direction of elevator to Down. \\n"});\par
237                         \}\par
238                         {\cf17 struct }passenger temp = *cur;\par
239                         temp.next = NULL; {\cf20 // removing this from passenger queue list}\par
240 \par
241                         {\cf18 int} arrival_floor_index = temp.arrival_floor - 1;\par
242                         add_passenger_floor(floor_array, arrival_floor_index, temp);\par
243                         stop_at_floor_global[temp.arrival_floor - 1] = {\cf17 true};\par
244                         passenger_queue = remove_passenger_queue(index, passenger_queue);\par
245                         index--; {\cf20 //list is smaller by one node.}\par
246                     \}\par
247 \par
248                     {\cf20 //is elevator at ground floor. Can cause issues at start.}\par
249                     {\cf19 else} {\cf19 if} (elevator_arr[i].cur_floor == 1)\par
250                     \{\par
251                         {\cf20 //change direction to move up}\par
252                         moving_lift_up(elevator_arr, i);\par
253                         {\cf17 struct }passenger temp = *cur;\par
254                         temp.next = NULL; {\cf20 // removing this from passenger queue list}\par
255 \par
256                         {\cf18 int} arrival_floor_index = temp.arrival_floor - 1;\par
257                         add_passenger_floor(floor_array, arrival_floor_index, temp);\par
258                         stop_at_floor_global[temp.arrival_floor - 1] = {\cf17 true};\par
259                         passenger_queue = remove_passenger_queue(index, passenger_queue);\par
260                         index--; {\cf20 //list is smaller by one node.}\par
261                     \}\par
262 \par
263                     {\cf19 else} {\cf20 //passenger in lift go in opposite direction of the lift}\par
264                     \{\par
265                         {\cf20 // bool to check if elevator and passenger inside are travelling in same direction}\par
266                         {\cf18 bool} passenger_elevator_dir = {\cf17 false};\par
267                         {\cf19 for} ({\cf18 int} j = 0; j < elevator_arr[i].passenger_count; j++)\par
268                         \{\par
269                             {\cf19 if} (elevator_arr[i].passenger_arr[j].in_elevator)\par
270                             \{\par
271                                 {\cf18 bool} up = elevator_arr[i].passenger_arr[j].dest_floor > elevator_arr[i].passenger_arr[j].arrival_floor;\par
272                                 {\cf19 if} (elevator_arr[i].direction_up == up || elevator_arr[i].direction_down != up)\par
273                                 \{\par
274                                     passenger_elevator_dir = {\cf17 true};\par
275                                     {\cf19 break};\par
276                                 \}\par
277                             \}\par
278                         \}\par
279 \par
280                         {\cf20 //if no passengers are travelling in direction of lift change lift direction}\par
281                         {\cf19 if} (!passenger_elevator_dir)\par
282                         \{\par
283                             {\cf19 if} (elevator_arr[i].direction_up)\par
284                             \{\par
285                                 moving_lift_down(elevator_arr, i);\par
286                             \}\par
287                             {\cf19 else} {\cf19 if} (elevator_arr[i].direction_down)\par
288                             \{\par
289                                 moving_lift_up(elevator_arr, i);\par
290                             \}\par
291 \par
292                             {\cf17 struct }passenger temp = *cur;\par
293                             temp.next = NULL; {\cf20 // removing this from passenger queue list}\par
294 \par
295                             {\cf18 int} arrival_floor_index = temp.arrival_floor - 1;\par
296                             add_passenger_floor(floor_array, arrival_floor_index, temp);\par
297                             stop_at_floor_global[temp.arrival_floor - 1] = {\cf17 true};\par
298                             passenger_queue = remove_passenger_queue(index, passenger_queue);\par
299                             index--; {\cf20 //list is smaller by one node.}\par
300                         \}\par
301                     \}\par
302                 \}\par
303 \par
304                 {\cf20 //potential bug here due to deleting nodes in remove_passenger_queue}\par
305 \par
306                 cur = passenger_queue; {\cf20 //bug fix start}\par
307                 {\cf19 if} (cur != NULL)       {\cf20 //incase we deleted only node queue}\par
308                 \{\par
309                     {\cf19 for} ({\cf18 int} q_index = 0; q_index < index + 1; q_index++)\par
310                     \{\par
311                         cur = cur->next; {\cf20 //iterate until we reach the spot of deletion}\par
312                     \}\par
313                 \} {\cf20 //bug fix end}\par
314                 index++;\par
315 \par
316             \} {\cf20 //End of while loop iterating over queue}\par
317 \par
318             {\cf20 //move elevator here}\par
319             {\cf19 if} (elevator_arr[i].passenger_count > 0) {\cf20 //if there are passengers then lift needs to move}\par
320             \{\par
321                 elevator_arr[i].moving = {\cf17 true};\par
322                 elevator_arr[i].between_floor = {\cf17 true};\par
323             \}\par
324             {\cf19 else}\par
325             \{\par
326                 elevator_arr[i].moving = {\cf17 false}; {\cf20 //elevator is stopped and empty now}\par
327                 {\cf19 if} (elevator_arr[i].timer != 0)\par
328                 \{\par
329                     elevator_arr[i].between_floor = {\cf17 true}; {\cf20 //time for passenger to drop out.}\par
330                 \}\par
331                 {\cf19 else}\par
332                 \{\par
333                     elevator_arr[i].between_floor = {\cf17 false}; {\cf20 //elevator is stationary at current floor and can be used again.}\par
334                     {\cf19 if} (elevator_arr[i].cur_floor == 1)\par
335                     \{ {\cf20 //elevator at ground floor can only move up.}\par
336                         moving_lift_up(elevator_arr, i);\par
337                     \}\par
338                     {\cf19 else} {\cf19 if} (elevator_arr[i].cur_floor == floor_count) {\cf20 //At top floor and can only move down}\par
339                     \{\par
340                         moving_lift_down(elevator_arr, i);\par
341                     \}\par
342                     {\cf19 else}\par
343                     \{ {\cf20 //elevator in middle can go anywhere}\par
344                         elevator_arr[i].direction_up = {\cf17 true};\par
345                         elevator_arr[i].direction_down = {\cf17 true};\par
346                     \}\par
347                 \}\par
348             \}\par
349 \par
350             {\cf19 if} (elevator_arr[i].timer > 0)\par
351             \{\par
352                 elevator_arr[i].timer--;\par
353             \}\par
354             {\cf19 if} (elevator_arr[i].timer == 0)\par
355             \{ {\cf20 //we may need to move to another floor}\par
356                 {\cf18 int} current_floor = elevator_arr[i].cur_floor;\par
357                 {\cf18 bool} passengers_above = {\cf17 false}; {\cf20 //are there passengers above for drop or pickup?}\par
358                 {\cf18 bool} passengers_below = {\cf17 false}; {\cf20 //are there passengers below for drop or pickup?}\par
359                 {\cf19 if} (elevator_arr[i].direction_up)\par
360                 \{\par
361                     {\cf19 for} ({\cf18 int} k = current_floor; k < floor_count; k++) {\cf20 //start at current floor and search up}\par
362                     \{                                                 {\cf20 //k = current floor becuse searching up and array numbering starts from 0 so curent_floor as index is 1 floor above}\par
363                         {\cf20 //if we are below a floor and need to stop on it to drop a passenger.}\par
364                         {\cf18 bool} condition_a = elevator_arr[i].stop_at_floor[k];\par
365                         {\cf20 // if we are below a floor and neee to stop on it to pick a passenger.}\par
366                         {\cf18 bool} condition_b = stop_at_floor_global[k];\par
367                         {\cf19 if} (condition_a || condition_b)\par
368                         \{\par
369                             passengers_above = {\cf17 true};\par
370                             elevator_arr[i].stop_at_floor[k] = {\cf17 true};\par
371                             stop_at_floor_global[k] = {\cf17 false}; {\cf20 //lift assigned to this floor}\par
372                             {\cf19 break};\par
373                         \}\par
374                     \}\par
375                 \}\par
376                 {\cf19 else} {\cf19 if} (elevator_arr[i].direction_down)\par
377                 \{\par
378                     {\cf19 for} ({\cf18 int} k = current_floor - 2; k >= 0; k--)\par
379                     \{ {\cf20 //current_floor-2 because of array numbering and file numbering mismatch}\par
380                         {\cf20 //if we are above a floor and need to stop on it to drop passengers.}\par
381                         {\cf18 bool} condition_a = elevator_arr[i].stop_at_floor[k];\par
382                         {\cf20 //if we are above a floor and need to stop on it to pick a passenger.}\par
383                         {\cf18 bool} condition_b = stop_at_floor_global[k];\par
384                         {\cf19 if} (condition_a || condition_b)\par
385                         \{\par
386                             passengers_below = {\cf17 true};\par
387                             elevator_arr[i].stop_at_floor[k] = {\cf17 true};\par
388                             stop_at_floor_global[k] = {\cf17 false}; {\cf20 //lift assigned to this floor}\par
389 \par
390                             {\cf19 break};\par
391                         \}\par
392                     \}\par
393                 \}\par
394 \par
395                 {\cf19 if} (passengers_above)\par
396                 \{\par
397                     current_floor++;\par
398                 \}\par
399                 {\cf19 else} {\cf19 if} (passengers_below)\par
400                 \{\par
401                     current_floor--;\par
402                 \}\par
403                 elevator_arr[i].cur_floor = current_floor; {\cf20 //changed the floor}\par
404                 {\cf19 if} (elevator_arr[i].stop_at_floor[current_floor - 1] || stop_at_floor_global[current_floor - 1])\par
405                 \{ {\cf20 //do we need to stop at this floor}\par
406                     elevator_arr[i].moving = {\cf17 false};\par
407                     elevator_arr[i].between_floor = {\cf17 false};\par
408                     elevator_arr[i].stop_at_floor[current_floor - 1] = {\cf17 true}; {\cf20 //setting to true so that the lift stops at this floor}\par
409                                                                              {\cf20 //stop_at_floor_global[current_floor - 1] = false;}\par
410                 \}\par
411                 {\cf19 else} {\cf19 if} (passengers_above || passengers_below) {\cf20 //we do not need to stop at this floor.}\par
412                 \{\par
413                     elevator_arr[i].moving = {\cf17 true};\par
414                     elevator_arr[i].between_floor = {\cf17 true};\par
415                     elevator_arr[i].timer += 3; {\cf20 //add 3 sec till next floor}\par
416                 \}\par
417                 {\cf19 else}\par
418                 \{\par
419                     elevator_arr[i].moving = {\cf17 false};\par
420                     elevator_arr[i].between_floor = {\cf17 false};\par
421                 \}\par
422 \par
423                 {\cf19 if} (elevator_arr[i].direction_up && !passengers_above)\par
424                 \{ {\cf20 //if no passengers above then lift should change direction to down.}\par
425                     {\cf19 if} (current_floor != 1 && elevator_arr[i].passenger_count > 0)\par
426                     \{\par
427                         moving_lift_down(elevator_arr, i);\par
428                     \}\par
429                 \}\par
430                 {\cf19 else} {\cf19 if} (elevator_arr[i].direction_down && !passengers_below)\par
431                 \{\par
432                     {\cf19 if} (current_floor != floor_count && elevator_arr[i].passenger_count > 0)\par
433                     \{\par
434                         moving_lift_up(elevator_arr, i);\par
435                     \}\par
436                 \}\par
437             \}\par
438 \par
439         \} {\cf20 //end of elevator loop}\par
440 \par
441         end_time = time(NULL);\par
442         time_difference = 0;\par
443         {\cf19 while} (time_difference < 1 && enable_realtime)\par
444         \{ {\cf20 //wait one second}\par
445             end_time = time(NULL);\par
446             time_difference = end_time - start_time;\par
447         \}\par
448         t++;\par
449     \}\par
450     {\cf17 struct }passenger dummy;          {\cf20 //placeholder to pass to log. it should not be used.}\par
451     travel_log_file(dummy, 0, 0, 3); {\cf20 //choose mode to write max,avg time to file.}\par
452     {\cf19 return} 1;\par
453 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/emergency_stop_handling.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/emergency_stop_handling.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/emergency_stop_handling.h}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains declaration for the emergency_stop_handling() function. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "structures.h"}\par
{\f2 #include "globals.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b emergency_stop_handling} (struct {\b elevator} ele[], unsigned int *timer){\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains declaration for the emergency_stop_handling() function. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Divyalakshmi Padmanaban \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/functions.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/functions.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/functions.h}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simply contains all the headers of the different function. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "structures.h"}\par
{\f2 #include "globals.h"}\par
{\f2 #include "add_passenger_floor.h"}\par
{\f2 #include "add_request_queue.h"}\par
{\f2 #include "count_passenger.h"}\par
{\f2 #include "create_elevator_array.h"}\par
{\f2 #include "create_floor_array.h"}\par
{\f2 #include "input_floors.h"}\par
{\f2 #include "input_lifts.h"}\par
{\f2 #include "is_lift_on_floor.h"}\par
{\f2 #include "moving_lift_down.h"}\par
{\f2 #include "moving_lift_up.h"}\par
{\f2 #include "passengers_drop.h"}\par
{\f2 #include "passengers_take_in.h"}\par
{\f2 #include "read_passenger.h"}\par
{\f2 #include "remove_passenger_floor.h"}\par
{\f2 #include "remove_passenger_queue.h"}\par
{\f2 #include "travel_log_file.h"}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simply contains all the headers of the different function. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
 \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/globals.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/globals.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/globals.h}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains declarations for globals elevator_count, passenger_count and floor_count. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b elevator_count}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b passenger_count}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b floor_count}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains declarations for globals elevator_count, passenger_count and floor_count. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v elevator_count\:globals.h}
{\xe \v globals.h\:elevator_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int elevator_count}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total number of elevators in the bulding \par
}{
Definition at line 10 of file globals.c.}\par
}
{\xe \v floor_count\:globals.h}
{\xe \v globals.h\:floor_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int floor_count}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The floor count of the building \par
}{
Definition at line 16 of file globals.c.}\par
}
{\xe \v passenger_count\:globals.h}
{\xe \v globals.h\:passenger_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int passenger_count}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total number of passengers checked from the passengers file text \par
}{
Definition at line 13 of file globals.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/input_after_stop.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/input_after_stop.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/input_after_stop.h}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the user input to determine status of simulation after encountering emergency stop. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b input_after_stop} (){\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the user input to determine status of simulation after encountering emergency stop. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Hariprasad Munusamy - {\f2 HariprasadMunusamy@cmail.carleton.ca} \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/input_floors.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/input_floors.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/input_floors.h}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Obtains the floor count-Total number of floors in the building. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "structures.h"}\par
{\f2 #include "globals.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b input_floors} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Obtains the floor count-Total number of floors in the building. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v input_floors\:input_floors.h}
{\xe \v input_floors.h\:input_floors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int input_floors (void )}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constraints If the floor count is 0 ,the function displays a error message and returns -1. If the floor count is less than 1(negative values) ,the function displays a error message and returns -1. If the floor count is greater than 100,the function displays a error message and returns -1. Floating point values entered considered to near integers. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The function accepts only values between 1 and 100 and returns the value;otherwise returns -1 and displays error message. \par
}}}{
Definition at line 20 of file input_floors.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21 \{\par
22     {\cf18 int} local_floor_count;\par
23 \par
24     printf({\cf22 "Enter the number of floors in the building-VALID INPUTS ARE FROM 1 TO 100\\n"});\par
25     puts({\cf22 "This Value should be greater than or equal to maximum floor number in input.txt file."});\par
26     scanf({\cf22 "%d"}, &local_floor_count);\par
27     {\cf20 //Following checks are performed to see if the entered value is erraneous.}\par
28     {\cf19 if} (local_floor_count == 0)\par
29     \{\par
30         printf({\cf22 "Entered number of floor invalid \\n"});\par
31         local_floor_count = -1;\par
32     \}\par
33     {\cf19 else} {\cf19 if} (local_floor_count < 1)\par
34     \{\par
35         printf({\cf22 "Entered number of floor is negative value and hence invalid \\n"});\par
36         local_floor_count = -1;\par
37     \}\par
38     {\cf19 else} {\cf19 if} (local_floor_count > 100)\par
39     \{\par
40         printf({\cf22 "Entered number of floor is greater than 100 and hence invalid \\n"});\par
41         local_floor_count = -1;\par
42     \}\par
43     {\cf20 //discards the values stored in stdin buffer.}\par
44     scanf({\cf22 "%*[^\\n]"});\par
45     {\cf19 return} local_floor_count;\par
46 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/input_lifts.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/input_lifts.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/input_lifts.h}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains declaration for the {\b input_lifts()} function. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "structures.h"}\par
{\f2 #include "globals.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b input_lifts} (int mode)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prompt the user to enter the number of lifts and takes the input. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains declaration for the {\b input_lifts()} function. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v input_lifts\:input_lifts.h}
{\xe \v input_lifts.h\:input_lifts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int input_lifts (int  {\i mode})}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prompt the user to enter the number of lifts and takes the input. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The function prompts the user to enter the number of lifts. If the lift count is less than one or greater than 100 (mode 0) or 10 (mode 1)the function displays an error message and returns -1. If the user enters anything other than a numeric entry. The function displays and error message, discards all inputs in stdin stream and returns -1. If the user enters numeric value. It accepts the only Whole number part of the entry and returns the entered whole number value.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i mode} \cell }{integer to select mode. mode 0 for 100 max, 1 for 10 max numbers.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
int Returns -1 if errors in input and integer if input is fine. \par
}}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
if the scanf does not read anything, clear from the stdin buffer and return -1\par
}{
Definition at line 28 of file input_lifts.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29 \{\par
30     {\cf18 int} temp;\par
31     puts({\cf22 "Please Enter an integer number for the number of Elevator in building."});\par
32     {\cf18 int} bounds = 0;\par
33     {\cf19 if} (mode == 0)\par
34     \{\par
35         puts({\cf22 "Valid entries are 1-100"});\par
36         bounds = 100;\par
37     \}\par
38     {\cf19 if} (mode == 1)\par
39     \{\par
40         puts({\cf22 "Valid entries are 1-10"});\par
41         bounds = 10;\par
42     \}\par
43     {\cf18 int} result = scanf({\cf22 "%d"}, &temp);\par
44     {\cf20 //printf("This is result %d \\n",result);}\par
45 \par
47     {\cf19 if} (result == 0)\par
48     \{\par
49         puts({\cf22 "Non-integer input entered. Please enter an integer.\\n"});\par
50         temp = -1;\par
51     \}\par
52     {\cf19 else} {\cf19 if} (temp < 1)\par
53     \{\par
54         puts({\cf22 "Value entered is less than 1"});\par
55         temp = -1;\par
56     \}\par
57     {\cf19 else} {\cf19 if} (temp > bounds)\par
58     \{\par
59         printf({\cf22 "Value entered is greater than %d\\n"}, bounds);\par
60         temp = -1;\par
61     \}\par
62     scanf({\cf22 "%*[^\\n]"}); {\cf20 //discards the leftover inputs in stdin buffer}\par
63     {\cf19 return} temp;\par
64 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/input_static_dynamic.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/input_static_dynamic.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/input_static_dynamic.h}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has the declaration for input_static_dynamic function. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b input_static_dynamic} (void){\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has the declaration for input_static_dynamic function. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Ritika Arora\par
}}@detail The function to decide which type of simulation user wants to run.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i void} \cell }{The function takes no inputs\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
int returns an integer value \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/is_lift_empty.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/is_lift_empty.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/is_lift_empty.h}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has the declaration for the is_lift_empty function @detail The function has two input parameters: one is an array of elevators of elevator type @detail and the other is the index of the array which can be used as the number of the elevator. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "structures.h"}\par
{\f2 #include "globals.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b is_lift_empty} (struct {\b elevator} elevator_arr[], unsigned int index){\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has the declaration for the is_lift_empty function @detail The function has two input parameters: one is an array of elevators of elevator type @detail and the other is the index of the array which can be used as the number of the elevator. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/is_lift_on_floor.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/is_lift_on_floor.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/is_lift_on_floor.h}
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains declaration for is_lift_on_floor function -Reads the elevator structure's attribute moving_floor. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "structures.h"}\par
{\f2 #include "globals.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b is_lift_on_floor} (struct {\b elevator} elev[], int index)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains declaration for is_lift_on_floor function -Reads the elevator structure's attribute moving_floor. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v is_lift_on_floor\:is_lift_on_floor.h}
{\xe \v is_lift_on_floor.h\:is_lift_on_floor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int is_lift_on_floor (struct {\b elevator}  {\i elev}[], int  {\i index})}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
@ details Constraints Checks if the input parameter index(i.e)elevator number;is within the range of number of elevators in building. If index is greater than the number of elevators actually present in building;error message will be displayed and returns -1. Checks the condition of the lift . {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i The} \cell }{function takes the elevator structure and index. @ return The function 0 if lift is not on floor elso 0. \cell }
{\row }
}
}{
Definition at line 22 of file is_lift_on_floor.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23 \{\par
24     {\cf19 if} (index >= elevator_count) {\cf20 //check on the input parameter which cannot be more than the number of elevators in the building.}\par
25     \{\par
26         fprintf(stderr, {\cf22 "Input parameter -Index is greater than the array ele[]-------- %d >= %d \\n"}, index, elevator_count);\par
27         exit(1);\par
28         {\cf19 return} -1;\par
29     \}\par
30 \par
31     {\cf19 if} (elev[index].between_floor == 1) {\cf20 //check on the value of between_floors that makes evident if the lift is on floor or in between.}\par
32     \{\par
33         {\cf19 return} 0;\par
34     \}\par
35     {\cf19 else} {\cf19 if} (elev[index].between_floor == 0)\par
36     \{\par
37         {\cf19 return} 1;\par
38     \}\par
39     {\cf19 else}\par
40     \{\par
41         fprintf(stderr, {\cf22 "Incorrect elev[index].between_floor Value : %d \\n"}, elev[index].between_floor);\par
42         exit(1);\par
43     \}\par
44 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/max_waiting_time.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/max_waiting_time.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/max_waiting_time.h}
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has the declaration for the max_waiting_time function @detail The function has one input parameter: time_difference which is the difference between the time passenger arrived and the time he got into the elevator. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "structures.h"}\par
{\f2 #include "globals.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

float {\b max_waiting_time} (float time_difference){\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has the declaration for the max_waiting_time function @detail The function has one input parameter: time_difference which is the difference between the time passenger arrived and the time he got into the elevator. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
float returns the maximum time taken by a passenger \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/moving_lift_down.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/moving_lift_down.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/moving_lift_down.h}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains declaration for moving_lift_down function that changes the direction of lift. the function is defination found in {\b moving_lift_down.c} }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "structures.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b moving_lift_down} (struct {\b elevator} elevator_arr[], unsigned int index)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
changes the direction of lift to down. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains declaration for moving_lift_down function that changes the direction of lift. the function is defination found in {\b moving_lift_down.c} \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v moving_lift_down\:moving_lift_down.h}
{\xe \v moving_lift_down.h\:moving_lift_down}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int moving_lift_down (struct {\b elevator}  {\i elevator_arr}[], unsigned int  {\i index})}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
changes the direction of lift to down. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function takes as input an elevator array and changes the direction of the elevator at the specified index position. sets {\b elevator.direction_up} to false and {\b elevator.direction_down} to true. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i elevator_arr[]} \cell }{an array of type struct elevator \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
int Returns -1 if errors in function call and 1 if function runs properly. \par
}}}{
Definition at line 25 of file moving_lift_down.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26 \{\par
27 \par
28     {\cf19 if} (index >= elevator_count)\par
29     \{\par
30         fprintf(stderr, {\cf22 "index >= elevator_arr size. %d >= %d \\n"}, index, elevator_count);\par
31         {\cf19 return} -1;\par
32     \}\par
33     elevator_arr[index].direction_up = {\cf17 false};\par
34     elevator_arr[index].direction_down = {\cf17 true};\par
35     {\cf19 return} 1;\par
36 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/moving_lift_up.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/moving_lift_up.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/moving_lift_up.h}
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has the declaration for moving_lift_up function @detail The function has two input parameters: one is an array of elevators elevator_arr of elevator type and the other is the index of the array which can be used as the number of the elevator. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "structures.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b moving_lift_up} (struct {\b elevator} elevator_arr[], unsigned int index){\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has the declaration for moving_lift_up function @detail The function has two input parameters: one is an array of elevators elevator_arr of elevator type and the other is the index of the array which can be used as the number of the elevator. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/passengers_drop.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/passengers_drop.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/passengers_drop.h}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
drops the passeger in corresponding floor }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "structures.h"}\par
{\f2 #include "globals.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b passengers_drop} (struct {\b elevator} elevator_arr[], int index, int cur_floor, unsigned int event_time)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
drops the passeger in corresponding floor \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v passengers_drop\:passengers_drop.h}
{\xe \v passengers_drop.h\:passengers_drop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int passengers_drop (struct {\b elevator}  {\i elevator_arr}[], int  {\i index}, int  {\i cur_floor}, unsigned int  {\i event_time})}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the passenger from the floor and the elevator array.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i elevator_arr} \cell }{array of struct elevators \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i index} \cell }{index of the elevator to operate on \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i cur_floor} \cell }{the current floor of the elevator \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i event_time} \cell }{the time this event happened.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The function return the number of passengers dropped. \par
}}}{
Definition at line 27 of file passengers_drop.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28 \{\par
29 \par
30     assert(index <= elevator_count);\par
31     assert(cur_floor <= floor_count);\par
32     assert(cur_floor == elevator_arr[index].cur_floor);\par
33 \par
34     {\cf18 int} passenger_dropped = 0;\par
35     {\cf18 int} max_passenger = elevator_arr[index].max_passenger;\par
36     {\cf20 //Loop to iterate the overall passengers in the elevator}\par
37     {\cf19 for} ({\cf18 int} i = 0; i < max_passenger; i++)\par
38     \{\par
39         {\cf18 bool} in_elevator = elevator_arr[index].passenger_arr[i].in_elevator;\par
40         {\cf19 if} (elevator_arr[index].passenger_arr[i].dest_floor == cur_floor && in_elevator)\par
41         \{\par
42             elevator_arr[index].passenger_arr[i].in_elevator = {\cf17 false}; {\cf20 //setting the status}\par
43             elevator_arr[index].passenger_count--;\par
44             passenger_dropped++;\par
45             {\cf17 struct }passenger temp = elevator_arr[index].passenger_arr[i];\par
46             travel_log_file(temp, event_time, index, 1); {\cf20 //choose mode to write to travel_log as we are removing passenger.}\par
47         \}\par
48     \}\par
49     {\cf19 return} passenger_dropped;\par
50 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/passengers_take_in.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/passengers_take_in.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/passengers_take_in.h}
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains declarations for passenger_take_in function. Used to add passenger to the provided elevator array entry }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "structures.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b passengers_take_in} (struct {\b elevator} elevator_arr[], int index, struct {\b passenger} *{\b floor_arr}[], int cur_floor, unsigned int event_time)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains declarations for passenger_take_in function. Used to add passenger to the provided elevator array entry \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v passengers_take_in\:passengers_take_in.h}
{\xe \v passengers_take_in.h\:passengers_take_in}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int passengers_take_in (struct {\b elevator}  {\i elevator_arr}[], int  {\i index}, struct {\b passenger} *  {\i floor_arr}[], int  {\i cur_floor}, unsigned int  {\i event_time})}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function removes adds a passenger from a queue to the elevator_array\par
This function take in an elevator, index of the elevator, array of floor and current_floor. and removes the passenger from the floor and adds it to elevator passenger array. \par
 {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i index} \cell }{int value that specifies the index of the elevator. index start at 0. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i elevator_arr} \cell }{pointer to elevator array. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i floor_arr} \cell }{array of pointers to passengers on floor. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i cur_florr} \cell }{int value that specifies the current floor. As described in elevator so start at 1 and equal to max_floor_count. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i event_time} \cell }{unsigned int the time the event has happened. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
return the number of passengers added to the elevator. \par
}}}{
Definition at line 28 of file passengers_take_in.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29 \{\par
30 \par
31     assert(index < elevator_count && index >= 0);\par
32     assert(cur_floor <= floor_count && cur_floor > 0);\par
33     assert(cur_floor == elevator_arr[index].cur_floor); {\cf20 //? test the case that both elevator and passenger are at same floor.}\par
34 \par
35     {\cf18 int} floor_index = cur_floor - 1; {\cf20 //input file floor start from 1 while floor array is indexed from 0 so this is needed}\par
36     {\cf18 int} passenger_capacity = elevator_arr[index].max_passenger;\par
37     {\cf18 int} passenger_added = 0;\par
38 \par
39     {\cf19 for} ({\cf18 int} i = 0; i < passenger_capacity; i++)\par
40     \{\par
41 \par
42         {\cf19 if} (!(elevator_arr[index].passenger_arr[i].in_elevator))\par
43         \{\par
44 \par
45             {\cf19 if} (floor_arr[floor_index] != NULL && elevator_arr[index].passenger_count < passenger_capacity)\par
46             \{\par
47                 {\cf17 struct }passenger temp = *(floor_arr[floor_index]);\par
48                 elevator_arr[index].passenger_arr[i] = temp;\par
49                 elevator_arr[index].passenger_arr[i].in_elevator = {\cf17 true};\par
50                 elevator_arr[index].passenger_count++;\par
51                 elevator_arr[index].stop_at_floor[temp.dest_floor - 1] = {\cf17 true}; {\cf20 //stop at this floor from drop off}\par
52                 passenger_added++;\par
53                 travel_log_file(*(floor_arr[floor_index]), event_time, index, 2); {\cf20 //choose mode to calculate avg,max times.}\par
54                 remove_passenger_floor(floor_arr, cur_floor);\par
55             \}\par
56             {\cf19 else}\par
57             \{\par
58                 {\cf19 break};\par
59             \}\par
60         \}\par
61     \}\par
62     {\cf19 return} passenger_added;\par
63 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/read_passenger.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/read_passenger.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/read_passenger.h}
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the input file for passenger id,arrival time,starting floor and destination floor. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "structures.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b read_passenger} (struct {\b passenger} *p){\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the input file for passenger id,arrival time,starting floor and destination floor. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/read_user_input_validate.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/read_user_input_validate.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/read_user_input_validate.h}
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains declarations for read_user_input_validate function. Reads the passenger information from the user console and adds it to the passenger structure after validating }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "structures.h"}\par
{\f2 #include "globals.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b read_user_input_validate} (struct {\b passenger} *passenger_info, unsigned int timer){\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains declarations for read_user_input_validate function. Reads the passenger information from the user console and adds it to the passenger structure after validating \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Ritika Arora\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i passenger_info} \cell }{pointer to the passenger structure containing data of the passenger. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i timer} \cell }{to get the time of simulation and store as time of arrival\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
void returns nothing \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/remove_passenger_floor.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/remove_passenger_floor.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/remove_passenger_floor.h}
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the declaration for the remove_passenger_floor. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "structures.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b remove_passenger_floor} (struct {\b passenger} *floor[], int cur_floor)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the declaration for the remove_passenger_floor. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v remove_passenger_floor\:remove_passenger_floor.h}
{\xe \v remove_passenger_floor.h\:remove_passenger_floor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int remove_passenger_floor (struct {\b passenger} *  {\i floordetails}[], int  {\i cur_floor})}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constraints The program terminates if the input parameter cur_floor(passenger details for this particular floor has to be deleted)is erraneous. (i.e)cur_floor must be within the range 1-100 and less than the floor_count(Total number of floors in the building ) {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i The} \cell }{function takes passenger structure and current floor. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Returns 1 on successful deletion of passenger details from specified floor. \par
}}}{
Definition at line 23 of file remove_passenger_floor.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24 \{\par
25 \par
26     assert(cur_floor > 0); {\cf20 //checks the value of cur_floor ;if it returns 0- terminates the program}\par
27     assert(cur_floor <= floor_count);\par
28     {\cf17 static} {\cf18 int} no_of_passengers_removed = 0;\par
29     {\cf18 int} floor_index = cur_floor - 1; {\cf20 //needed because floor array strt at 0 and elevator floor at 1}\par
30     {\cf17 struct }passenger *temp;\par
31     temp = floordetails[floor_index];\par
32     floordetails[floor_index] = floordetails[floor_index]->next;\par
33     printf({\cf22 "Passenger %d from floor %d removed. No of passengers removed: %d\\n"}, temp->id, cur_floor, ++no_of_passengers_removed);\par
34     free(temp);\par
35     {\cf19 return} 1;\par
36 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/remove_passenger_queue.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/remove_passenger_queue.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/remove_passenger_queue.h}
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the declaration for remove_passenger_queue function that remoove passenger from a queue }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "structures.h"}\par
{\f2 #include "globals.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b passenger} * {\b remove_passenger_queue} (int index, struct {\b passenger} *head)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the declaration for remove_passenger_queue function that remoove passenger from a queue \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v remove_passenger_queue\:remove_passenger_queue.h}
{\xe \v remove_passenger_queue.h\:remove_passenger_queue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b passenger}* remove_passenger_queue (int  {\i index}, struct {\b passenger} *  {\i head})}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function removes a passenger from a queue at given index and frees the memory\par
The function remomves and frees memory location at given index. if the given index is at the head the head is removed and new head is returned. If index is greater then length of queue the function causes program to exit.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i index} \cell }{int value that points to index of queue to return. indices start at 0. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i head} \cell }{pointer to head of the queue.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
return the value of the head. head will point to new value head if index is 0. \par
}}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
< Precondition that head not be Null\par
< Precondition that index not be negative\par
< stores the current position of pointer to be used in while loop\par
Iterate through the queue until we are one node behind the node we want to delete. Or next node is null. Set next of previous node to next node and store the node to delete in temp. use free to delete current node.\par
This is precondition checks if index was greater than queue length and this cannot be done at start as we do not know total length of queue at begining. the check is cur->nect != NULL as we stop before element to be removed. if cur->next = NULL it means the index is greater than length as we are at end list and should have stopped at index-1.\par
}{
Definition at line 25 of file remove_passenger_queue.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26 \{\par
27 \par
28     assert(head != NULL); \par
29     assert(index > -1);   \par
30 \par
31     {\cf17 static} {\cf18 int} removal_count = 0;\par
32     {\cf17 struct }passenger *temp = NULL;\par
33     {\cf17 struct }passenger *cur = head; \par
34     {\cf19 if} (index == 0)\par
35     \{\par
36         temp = head;\par
37         head = head->next;\par
38         printf({\cf22 "The passenger Removed from cue is:%d count is:%d \\n."}, temp->id, ++removal_count);\par
39         free(temp);\par
40         {\cf19 return} head;\par
41     \}\par
42     {\cf19 else}\par
43     \{\par
44         {\cf18 int} i = 0;\par
45 \par
52         {\cf19 while} (i < index - 1 && cur->next != NULL)\par
53         \{\par
54             cur = cur->next;\par
55             i++;\par
56         \}\par
57 \par
63         assert(cur->next != NULL);\par
64 \par
65         temp = cur->next;\par
66         cur->next = temp->next;\par
67         printf({\cf22 "The passenger Removed from cue is:%d count is:%d \\n."}, temp->id, ++removal_count);\par
68         free(temp);\par
69     \}\par
70     {\cf19 return} head;\par
71 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/simulations.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/simulations.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/simulations.h}
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
this file simply includes the header files of the two simulations. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "static_simulation.h"}\par
{\f2 #include "dynamic_simulation.h"}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
this file simply includes the header files of the two simulations. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/static_simulation.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/static_simulation.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/static_simulation.h}
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains the declaration of the function static_simulation The function carries out the static simulation of the project. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b static_simulation} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function contains the working logic of the elevator array function for static release. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains the declaration of the function static_simulation The function carries out the static simulation of the project. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v static_simulation\:static_simulation.h}
{\xe \v static_simulation.h\:static_simulation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int static_simulation (void )}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function contains the working logic of the elevator array function for static release. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
@detail Contains the logic for the static release. It contains the main logic loop for travel of elevators. The loop for placing passengers on floors and the complete flow of the program.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
return 1 for succesfull completion. \par
}}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A boolean array that shows if elevator needs to stop at a floor. to pick a passenger.\par
Array conatining Elevators\par
Array to pointer of type passenger. Stores passengers on floors.\par
stores the passengers from input file.\par
main time counter\par
A queue of request made by passengers\par
}{
Definition at line 21 of file static_simulation.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22 \{\par
23 \par
24     elevator_count = -1;\par
25     {\cf19 while} (elevator_count == -1)\par
26     \{\par
27         elevator_count = input_lifts(0);\par
28     \}\par
29     floor_count = -1;\par
30 \par
31     {\cf19 while} (floor_count == -1)\par
32     \{\par
33         floor_count = input_floors();\par
34     \}\par
35     {\cf18 bool} *stop_at_floor_global = ({\cf18 bool} *)calloc(floor_count, {\cf17 sizeof}({\cf18 bool})); \par
36     {\cf17 struct }elevator *elevator_arr = create_elevator_array(elevator_count);  \par
37     {\cf17 struct }passenger **floor_array = create_floor_array(floor_count);       \par
38     passenger_count = count_passenger();\par
39     {\cf17 struct }passenger *passenger_array = ({\cf17 struct }passenger *)calloc(passenger_count, {\cf17 sizeof}({\cf17 struct} passenger)); \par
40     read_passenger(passenger_array);\par
41     {\cf18 unsigned} {\cf18 int} t = 0;                       \par
42     {\cf17 struct }passenger *passenger_queue = NULL; \par
43 \par
44     {\cf18 int} prev_time_index = 0;\par
45 \par
46     {\cf19 while} (t < 1000) {\cf20 //86400 for whole day}\par
47     \{\par
48 \par
49         {\cf20 // Add passenger with current time step to queue}\par
50         {\cf19 for} ({\cf18 int} i_pass = prev_time_index; i_pass < passenger_count; i_pass++) {\cf20 //debugged works perfectly}\par
51         \{\par
52 \par
53             {\cf20 //Assume the passenger_array is sorted by arrival time.}\par
54             {\cf20 //prev_time_index prevents us from starting at previous index}\par
55             {\cf19 if} (passenger_array[i_pass].arrival_time == t)\par
56             \{\par
57 \par
58                 passenger_queue = add_request_queue(passenger_queue, passenger_array[i_pass]);\par
59                 prev_time_index++;\par
60             \}\par
61             {\cf19 else}\par
62             \{\par
63                 {\cf19 break};\par
64             \}\par
65         \}\par
66 \par
67         {\cf19 for} ({\cf18 int} i = 0; i < elevator_count; i++)\par
68         \{\par
69 \par
70             {\cf19 if} (is_lift_on_floor(elevator_arr, i))\par
71             \{\par
72                 {\cf18 int} drop_delay = 0;\par
73                 {\cf18 int} add_delay = 0;\par
74                 {\cf18 int} stop_change = elevator_arr[i].cur_floor - 1;\par
75                 {\cf19 if} (elevator_arr[i].passenger_count > 0)\par
76                 \{\par
77                     {\cf19 if} (elevator_arr[i].stop_at_floor[stop_change])\par
78                     \{ {\cf20 //remove any passengers that need to get off}\par
79                         drop_delay = passengers_drop(elevator_arr, i, elevator_arr[i].cur_floor, t);\par
80 \par
81                         {\cf19 if} (drop_delay > 0 || elevator_arr[i].passenger_count >= elevator_arr[i].max_passenger) {\cf20 //dropped passengers here or lift full}\par
82                         \{\par
83                             elevator_arr[i].stop_at_floor[stop_change] = {\cf17 false}; {\cf20 //dropped passengers here}\par
84                         \}\par
85                     \}\par
86                 \}\par
87                 {\cf19 if} (elevator_arr[i].passenger_count < elevator_arr[i].max_passenger)\par
88                 \{\par
89 \par
90                     add_delay = passengers_take_in(elevator_arr, i, floor_array, elevator_arr[i].cur_floor, t);\par
91                     elevator_arr[i].stop_at_floor[stop_change] = {\cf17 false};\par
92                     {\cf19 if} (floor_array[stop_change] == NULL)\par
93                     \{\par
94                         stop_at_floor_global[stop_change] = {\cf17 false};\par
95                     \}\par
96                     {\cf19 else}\par
97                     \{ {\cf20 //happens in case the lift gets full and their are still passengers on floor.}\par
98                         stop_at_floor_global[stop_change] = {\cf17 true};\par
99                     \}\par
100                     elevator_arr[i].stop_at_floor[stop_change] = {\cf17 false}; {\cf20 //lift has taken in or dropped passengers or is full and has completed it purpose on floor so we set to false.}\par
101                 \}\par
102                 {\cf18 int} total_delay = 2 * drop_delay + 2 * add_delay;\par
103                 elevator_arr[i].timer += total_delay;\par
104             \}\par
105 \par
106             {\cf17 struct }passenger *cur = passenger_queue;\par
107             {\cf18 int} index = 0;\par
108             {\cf19 while} (cur != NULL)\par
109             \{ {\cf20 //iterating over passenger queue}\par
110 \par
111                 {\cf18 bool} direction_up = (cur->arrival_floor <= cur->dest_floor); {\cf20 //passenger direction up}\par
112                 {\cf18 bool} direction_down = (cur->arrival_floor >= cur->dest_floor);\par
113                 {\cf19 if} (elevator_arr[i].direction_up == direction_up || elevator_arr[i].direction_down == direction_down)\par
114                 \{\par
115                     {\cf18 bool} is_above = cur->arrival_floor >= elevator_arr[i].cur_floor;\par
116                     {\cf18 bool} is_below = cur->arrival_floor <= elevator_arr[i].cur_floor;\par
117                     {\cf19 if} (elevator_arr[i].direction_up == is_above || elevator_arr[i].direction_down == is_below)\par
118                     \{ {\cf20 //elevator can pick this person up}\par
119                         {\cf17 struct }passenger temp = *cur;\par
120                         temp.next = NULL;                                 {\cf20 // removing this from passenger queue list}\par
121                         {\cf18 int} arrival_floor_index = temp.arrival_floor - 1; {\cf20 //-1 because of mismatch between array and input file}\par
122 \par
123                         add_passenger_floor(floor_array, arrival_floor_index, temp);\par
124                         stop_at_floor_global[temp.arrival_floor - 1] = {\cf17 true};\par
125                         passenger_queue = remove_passenger_queue(index, passenger_queue);\par
126                         index--; {\cf20 //list is smaller by one node.}\par
127                     \}\par
128                 \}\par
129 \par
130                 {\cf19 else}\par
131                 \{\par
132                     {\cf20 //is elevator at top floor}\par
133                     {\cf19 if} (elevator_arr[i].cur_floor == floor_count)\par
134                     \{\par
135                         {\cf20 //change direction to move down}\par
136                         {\cf18 int} success = moving_lift_down(elevator_arr, i);\par
137                         {\cf19 if} (success == -1)\par
138                         \{\par
139                             fprintf(stderr, {\cf22 "Could not change direction of elevator to Down. \\n"});\par
140                         \}\par
141                         {\cf17 struct }passenger temp = *cur;\par
142                         temp.next = NULL; {\cf20 // removing this from passenger queue list}\par
143 \par
144                         {\cf18 int} arrival_floor_index = temp.arrival_floor - 1;\par
145                         add_passenger_floor(floor_array, arrival_floor_index, temp);\par
146                         stop_at_floor_global[temp.arrival_floor - 1] = {\cf17 true};\par
147                         passenger_queue = remove_passenger_queue(index, passenger_queue);\par
148                         index--; {\cf20 //list is smaller by one node.}\par
149                     \}\par
150 \par
151                     {\cf20 //is elevator at ground floor. Can cause issues at start.}\par
152                     {\cf19 else} {\cf19 if} (elevator_arr[i].cur_floor == 1)\par
153                     \{\par
154                         {\cf20 //change direction to move up}\par
155                         moving_lift_up(elevator_arr, i);\par
156                         {\cf17 struct }passenger temp = *cur;\par
157                         temp.next = NULL; {\cf20 // removing this from passenger queue list}\par
158 \par
159                         {\cf18 int} arrival_floor_index = temp.arrival_floor - 1;\par
160                         add_passenger_floor(floor_array, arrival_floor_index, temp);\par
161                         stop_at_floor_global[temp.arrival_floor - 1] = {\cf17 true};\par
162                         passenger_queue = remove_passenger_queue(index, passenger_queue);\par
163                         index--; {\cf20 //list is smaller by one node.}\par
164                     \}\par
165 \par
166                     {\cf19 else} {\cf20 //passenger in lift go in opposite direction of the lift}\par
167                     \{\par
168                         {\cf20 // bool to check if elevator and passenger inside are travelling in same direction}\par
169                         {\cf18 bool} passenger_elevator_dir = {\cf17 false};\par
170                         {\cf19 for} ({\cf18 int} j = 0; j < elevator_arr[i].passenger_count; j++)\par
171                         \{\par
172                             {\cf19 if} (elevator_arr[i].passenger_arr[j].in_elevator)\par
173                             \{\par
174                                 {\cf18 bool} up = elevator_arr[i].passenger_arr[j].dest_floor > elevator_arr[i].passenger_arr[j].arrival_floor;\par
175                                 {\cf19 if} (elevator_arr[i].direction_up == up || elevator_arr[i].direction_down != up)\par
176                                 \{\par
177                                     passenger_elevator_dir = {\cf17 true};\par
178                                     {\cf19 break};\par
179                                 \}\par
180                             \}\par
181                         \}\par
182 \par
183                         {\cf20 //if no passengers are travelling in direction of lift change lift direction}\par
184                         {\cf19 if} (!passenger_elevator_dir)\par
185                         \{\par
186                             {\cf19 if} (elevator_arr[i].direction_up)\par
187                             \{\par
188                                 moving_lift_down(elevator_arr, i);\par
189                             \}\par
190                             {\cf19 else} {\cf19 if} (elevator_arr[i].direction_down)\par
191                             \{\par
192                                 moving_lift_up(elevator_arr, i);\par
193                             \}\par
194 \par
195                             {\cf17 struct }passenger temp = *cur;\par
196                             temp.next = NULL; {\cf20 // removing this from passenger queue list}\par
197 \par
198                             {\cf18 int} arrival_floor_index = temp.arrival_floor - 1;\par
199                             add_passenger_floor(floor_array, arrival_floor_index, temp);\par
200                             stop_at_floor_global[temp.arrival_floor - 1] = {\cf17 true};\par
201                             passenger_queue = remove_passenger_queue(index, passenger_queue);\par
202                             index--; {\cf20 //list is smaller by one node.}\par
203                         \}\par
204                     \}\par
205                 \}\par
206 \par
207                 {\cf20 //potential bug here due to deleting nodes in remove_passenger_queue}\par
208 \par
209                 cur = passenger_queue; {\cf20 //bug fix start}\par
210                 {\cf19 if} (cur != NULL)       {\cf20 //incase we deleted only node queue}\par
211                 \{\par
212                     {\cf19 for} ({\cf18 int} q_index = 0; q_index < index + 1; q_index++)\par
213                     \{\par
214                         cur = cur->next; {\cf20 //iterate until we reach the spot of deletion}\par
215                     \}\par
216                 \} {\cf20 //bug fix end. bug fixed}\par
217                 index++;\par
218 \par
219             \} {\cf20 //End of while loop iterating over queue}\par
220 \par
221             {\cf20 //move elevator here}\par
222             {\cf19 if} (elevator_arr[i].passenger_count > 0) {\cf20 //if there are passengers then lift needs to move}\par
223             \{\par
224                 elevator_arr[i].moving = {\cf17 true};\par
225                 elevator_arr[i].between_floor = {\cf17 true};\par
226             \}\par
227             {\cf19 else}\par
228             \{\par
229                 elevator_arr[i].moving = {\cf17 false}; {\cf20 //elevator is stopped and empty now}\par
230                 {\cf19 if} (elevator_arr[i].timer != 0)\par
231                 \{\par
232                     elevator_arr[i].between_floor = {\cf17 true}; {\cf20 //time for passenger to drop out.}\par
233                 \}\par
234                 {\cf19 else}\par
235                 \{\par
236                     elevator_arr[i].between_floor = {\cf17 false}; {\cf20 //elevator is stationary at current floor and can be used again.}\par
237                     {\cf19 if} (elevator_arr[i].cur_floor == 1)\par
238                     \{ {\cf20 //elevator at ground floor can only move up.}\par
239                         moving_lift_up(elevator_arr, i);\par
240                     \}\par
241                     {\cf19 else} {\cf19 if} (elevator_arr[i].cur_floor == floor_count) {\cf20 //At top floor and can only move down}\par
242                     \{\par
243                         moving_lift_down(elevator_arr, i);\par
244                     \}\par
245                     {\cf19 else}\par
246                     \{ {\cf20 //elevator in middle can go anywhere}\par
247                         elevator_arr[i].direction_up = {\cf17 true};\par
248                         elevator_arr[i].direction_down = {\cf17 true};\par
249                     \}\par
250                 \}\par
251             \}\par
252 \par
253             {\cf19 if} (elevator_arr[i].timer > 0)\par
254             \{\par
255                 elevator_arr[i].timer--;\par
256             \}\par
257             {\cf19 if} (elevator_arr[i].timer == 0)\par
258             \{ {\cf20 //we may need to move to another floor}\par
259                 {\cf18 int} current_floor = elevator_arr[i].cur_floor;\par
260                 {\cf18 bool} passengers_above = {\cf17 false}; {\cf20 //are there passengers above for drop or pickup?}\par
261                 {\cf18 bool} passengers_below = {\cf17 false}; {\cf20 //are there passengers below for drop or pickup?}\par
262                 {\cf19 if} (elevator_arr[i].direction_up)\par
263                 \{\par
264                     {\cf19 for} ({\cf18 int} k = current_floor; k < floor_count; k++) {\cf20 //start at current floor and search up}\par
265                     \{                                                 {\cf20 //k = current floor becuse searching up and array numbering starts from 0 so curent_floor as index is 1 floor above}\par
266                         {\cf20 //if we are below a floor and need to stop on it to drop a passenger.}\par
267                         {\cf18 bool} condition_a = elevator_arr[i].stop_at_floor[k];\par
268                         {\cf20 // if we are below a floor and neee to stop on it to pick a passenger.}\par
269                         {\cf18 bool} condition_b = stop_at_floor_global[k];\par
270                         {\cf19 if} (condition_a || condition_b)\par
271                         \{\par
272                             passengers_above = {\cf17 true};\par
273                             elevator_arr[i].stop_at_floor[k] = {\cf17 true};\par
274                             stop_at_floor_global[k] = {\cf17 false}; {\cf20 //lift assigned to this floor}\par
275                             {\cf19 break};\par
276                         \}\par
277                     \}\par
278                 \}\par
279                 {\cf19 else} {\cf19 if} (elevator_arr[i].direction_down)\par
280                 \{\par
281                     {\cf19 for} ({\cf18 int} k = current_floor - 2; k >= 0; k--)\par
282                     \{ {\cf20 //current_floor-2 because of array numbering and file numbering mismatch}\par
283                         {\cf20 //if we are above a floor and need to stop on it to drop passengers.}\par
284                         {\cf18 bool} condition_a = elevator_arr[i].stop_at_floor[k];\par
285                         {\cf20 //if we are above a floor and need to stop on it to pick a passenger.}\par
286                         {\cf18 bool} condition_b = stop_at_floor_global[k];\par
287                         {\cf19 if} (condition_a || condition_b)\par
288                         \{\par
289                             passengers_below = {\cf17 true};\par
290                             elevator_arr[i].stop_at_floor[k] = {\cf17 true};\par
291                             stop_at_floor_global[k] = {\cf17 false}; {\cf20 //lift assigned to this floor}\par
292 \par
293                             {\cf19 break};\par
294                         \}\par
295                     \}\par
296                 \}\par
297 \par
298                 {\cf19 if} (passengers_above)\par
299                 \{\par
300                     current_floor++;\par
301                 \}\par
302                 {\cf19 else} {\cf19 if} (passengers_below)\par
303                 \{\par
304                     current_floor--;\par
305                 \}\par
306                 elevator_arr[i].cur_floor = current_floor; {\cf20 //changed the floor}\par
307                 {\cf19 if} (elevator_arr[i].stop_at_floor[current_floor - 1] || stop_at_floor_global[current_floor - 1])\par
308                 \{ {\cf20 //do we need to stop at this floor}\par
309                     elevator_arr[i].moving = {\cf17 false};\par
310                     elevator_arr[i].between_floor = {\cf17 false};\par
311                     elevator_arr[i].stop_at_floor[current_floor - 1] = {\cf17 true}; {\cf20 //setting to true so that the lift stops at this floor}\par
312                 \}\par
313                 {\cf19 else} {\cf19 if} (passengers_above || passengers_below) {\cf20 //we do not need to stop at this floor.}\par
314                 \{\par
315                     elevator_arr[i].moving = {\cf17 true};\par
316                     elevator_arr[i].between_floor = {\cf17 true};\par
317                     elevator_arr[i].timer += 3; {\cf20 //add 3 sec till next floor}\par
318                 \}\par
319                 {\cf19 else}\par
320                 \{\par
321                     elevator_arr[i].moving = {\cf17 false};\par
322                     elevator_arr[i].between_floor = {\cf17 false};\par
323                 \}\par
324 \par
325                 {\cf19 if} (elevator_arr[i].direction_up && !passengers_above)\par
326                 \{ {\cf20 //if no passengers above then lift should change direction to down.}\par
327                     {\cf19 if} (current_floor != 1 && elevator_arr[i].passenger_count > 0)\par
328                     \{\par
329                         moving_lift_down(elevator_arr, i);\par
330                     \}\par
331                 \}\par
332                 {\cf19 else} {\cf19 if} (elevator_arr[i].direction_down && !passengers_below)\par
333                 \{\par
334                     {\cf19 if} (current_floor != floor_count && elevator_arr[i].passenger_count > 0)\par
335                     \{\par
336                         moving_lift_up(elevator_arr, i);\par
337                     \}\par
338                 \}\par
339             \}\par
340 \par
341         \} {\cf20 //end of elevator loop}\par
342 \par
343         t++;\par
344     \}\par
345     {\cf17 struct }passenger dummy;          {\cf20 //placeholder to pass to log. it should not be used.}\par
346     travel_log_file(dummy, 0, 0, 3); {\cf20 //choose mode to write max,avg time to file.}\par
347     {\cf19 return} 1;\par
348 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/structures.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/structures.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/structures.h}
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains declarations for structure passenger, elevator to be used in the program. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdbool.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b passenger}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
structure to store important information about a passenger. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b elevator}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
structure to store important information about an elevator. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains declarations for structure passenger, elevator to be used in the program. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/include/travel_log_file.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/include/travel_log_file.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/include/travel_log_file.h}
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the function declaration for {\b travel_log_file()} function which writes the travel history of passenger in the lift. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "structures.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b travel_log_file} (struct {\b passenger} traveler, unsigned int event_time, int elevator_index, int mode)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the function declaration for {\b travel_log_file()} function which writes the travel history of passenger in the lift. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v travel_log_file\:travel_log_file.h}
{\xe \v travel_log_file.h\:travel_log_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void travel_log_file (struct {\b passenger}  {\i traveler}, unsigned int  {\i event_time}, int  {\i elevator_index}, int  {\i mode})}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function generates and updates the outputput files for data processin\par
This function generates the output file waiting_times.txt and travel_log.txt which contain the average and max waiting time, and the user_id,elevator_id, passenger arrival time passenger leaving time.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i traveler} \cell }{struct containing details about the passenger \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i event_time} \cell }{the time the event to be recorded happened. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i elevator_index} \cell }{the index of the elevator the passenger was in. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i mode} \cell }{1 for writing to travel_log.txt, 2 for calculating average and max time,3 for writing waiting_times.txt log file)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
does not return an value \par
}}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This keeps track if the output path file is being opened for first time\par
relative path to the travel_log.txt file path\par
}{
Definition at line 30 of file travel_log_file.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 31 \{\par
32 \par
33     {\cf17 static} {\cf18 bool} first_call = {\cf17 true};                             \par
34     {\cf18 char} *travel_file_path = {\cf22 "data/travel_log.txt"};            \par
35     {\cf18 char} *waiting_times_files_path = {\cf22 "data/waiting_times.txt"}; {\cf20 //relative path to waiting_times.txt file path}\par
36     FILE *f;\par
37     {\cf18 float} diff;\par
38     {\cf19 switch} (mode)\par
39     \{\par
40 \par
41     {\cf19 case} 1: {\cf20 //This case is to write to travel_log file}\par
42         {\cf19 if} (first_call)\par
43         \{\par
44             f = fopen(travel_file_path, {\cf22 "w+"});\par
45             {\cf19 if} (f == NULL)\par
46             \{\par
47                 fprintf(stderr, {\cf22 "Could not create/open travel_log.txt file.\\n"});\par
48                 exit(-1);\par
49             \}\par
50             first_call = {\cf17 false};\par
51             fprintf(f, {\cf22 "Passenger_ID,Elevator_ID,Passenger_In_time,Passenger_Entry_floor,Passenger_Out_time,Passenger_Exit_floor\\n"});\par
52         \}\par
53         {\cf19 else}\par
54         \{\par
55             f = fopen(travel_file_path, {\cf22 "a+"});\par
56             {\cf19 if} (f == NULL)\par
57             \{\par
58                 fprintf(stderr, {\cf22 "Could not create/open travel_log.txt file.\\n"});\par
59                 exit(-1);\par
60             \}\par
61         \}\par
62 \par
63         {\cf18 int} {\cf18 id} = traveler.id;\par
64         {\cf18 int} in_time = traveler.arrival_time;\par
65         {\cf18 int} in_floor = traveler.arrival_floor;\par
66         {\cf18 int} out_floor = traveler.dest_floor;\par
67         fprintf(f, {\cf22 "%d,%d,%d,%d,%d,%d\\n"}, {\cf18 id}, elevator_index, in_time, in_floor, event_time, out_floor);\par
68         fflush(f);\par
69         fclose(f);\par
70         {\cf19 break};\par
71     {\cf19 case} 2:\par
72         {\cf20 //This case is to calculate max and average wait time.}\par
73 \par
74         diff = event_time - traveler.arrival_time;\par
75         {\cf19 if} (diff < 0.0)\par
76         \{\par
77             fprintf(stderr, {\cf22 "Negative time difference.\\n"});\par
78             exit(-1);\par
79         \}\par
80         average_waiting_time(diff);\par
81         max_waiting_time(diff);\par
82         {\cf19 break};\par
83     {\cf19 case} 3: {\cf20 //This case is to write to waiting time}\par
84         f = fopen(waiting_times_files_path, {\cf22 "w+"});\par
85         {\cf19 if} (f == NULL)\par
86         \{\par
87             fprintf(stderr, {\cf22 "Could not create waiting_times.txt file.\\n"});\par
88             exit(-1);\par
89         \}\par
90         {\cf18 float} avg_time = average_waiting_time(-1.0);\par
91         {\cf18 float} max_time = max_waiting_time(-1.0);\par
92         fprintf(f, {\cf22 "Average Waiting time of Passenger: %f\\n"}, avg_time);\par
93         fprintf(f, {\cf22 "Maximum Waiting time of Passenger: %f\\n"}, max_time);\par
94         fflush(f);\par
95         fclose(f);\par
96         {\cf19 break};\par
97     {\cf19 default}:\par
98         fprintf(stderr, {\cf22 "Incorrect mode selection."});\par
99         exit(-1);\par
100     \}\par
101 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/add_passenger_floor.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/add_passenger_floor.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/add_passenger_floor.c}
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the definition for add_passenger_floor file. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "add_passenger_floor.h"}\par
{\f2 #include "structures.h"}\par
{\f2 #include "globals.h"}\par
{\f2 #include <assert.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add_passenger_floor} (struct {\b passenger} *floor[], int index, struct {\b passenger} passenger_info)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a passenger to the floor. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the definition for add_passenger_floor file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v add_passenger_floor\:add_passenger_floor.c}
{\xe \v add_passenger_floor.c\:add_passenger_floor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void add_passenger_floor (struct {\b passenger} *  {\i floor}[], int  {\i index}, struct {\b passenger}  {\i passenger_info})}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a passenger to the floor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
@detail takes a floor array. The index of floor and passenger info. It then allocates a memory location and add the passenger to the passenger queue on that floor. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i floor} \cell }{an array of pointer of type struct passenger, Used to form passenger queue on each floor. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i index} \cell }{the index at to add the passenger. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i passenger_info} \cell }{struct passenger that contains the information about the passenger.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
void does not return anythin \par
}}}{
Definition at line 24 of file add_passenger_floor.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25 \{\par
26 \par
27     assert(index >= 0);\par
28     assert(index < floor_count);\par
29     {\cf17 static} {\cf18 int} no_of_passengers_added = 0;\par
30     {\cf17 struct }passenger *cur;\par
31     cur = floor[index];\par
32     {\cf19 if} (cur == NULL)\par
33     \{\par
34         {\cf17 struct }passenger *temp = ({\cf17 struct }passenger *)malloc({\cf17 sizeof}({\cf17 struct} passenger));\par
35         *temp = passenger_info;\par
36         floor[index] = temp;\par
37         floor[index]->next = NULL;\par
38         printf({\cf22 "passenger %d arrived at floor: %d. No of passengers Added: %d\\n"}, temp->id, index + 1, ++no_of_passengers_added);\par
39         {\cf19 return};\par
40     \}\par
41     {\cf19 while} (cur->next != NULL)\par
42     \{\par
43         cur = cur->next;\par
44     \}\par
45 \par
46     {\cf17 struct }passenger *temp = ({\cf17 struct }passenger *)malloc({\cf17 sizeof}({\cf17 struct} passenger));\par
47     *temp = passenger_info;\par
48     cur->next = temp;\par
49     temp->next = NULL;\par
50     printf({\cf22 "passenger %d arrived at floor: %d. No of passengers Added: %d\\n"}, temp->id, index + 1, ++no_of_passengers_added);\par
51     {\cf19 return};\par
52 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/add_request_queue.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/add_request_queue.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/add_request_queue.c}
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the definition of add_request_queue }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "add_request_queue.h"}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b passenger} * {\b add_request_queue} (struct {\b passenger} *head, struct {\b passenger} passenger_queue)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a passenger struct to the passenger queue. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the definition of add_request_queue \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v add_request_queue\:add_request_queue.c}
{\xe \v add_request_queue.c\:add_request_queue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b passenger}* add_request_queue (struct {\b passenger} *  {\i head}, struct {\b passenger}  {\i passenger_queue})}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a passenger struct to the passenger queue. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a passenger to passenger queue. This function can be used to make queues for the requests from passengers from the file or on a floor. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i head} \cell }{is a pointer to the head of the queue \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i passenger_queue} \cell }{passenger struct containing data of the passenger. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
passenger* returns pointer to the updated head of queue if operation is fine. head ptr is unchanged if memory cannot be allocated. \par
}}}{
Definition at line 21 of file add_request_queue.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22 \{\par
23     {\cf17 struct }passenger *temp = ({\cf17 struct }passenger *)malloc({\cf17 sizeof}({\cf17 struct} passenger));\par
24     *temp = passenger_queue;\par
25     {\cf17 struct }passenger *cur = head;\par
26 \par
27     {\cf19 if} (temp == NULL)\par
28     \{\par
29         fprintf(stderr, {\cf22 "MEMORY ALLOCATION FAILED IN add_request_queue. \\n"});\par
30         fprintf(stderr, {\cf22 "SKIPPING ADDING PASSENGER TO QUEUE"});\par
31         {\cf19 return} head;\par
32     \}\par
33     {\cf19 if} (head == NULL)\par
34     \{\par
35         temp->next = NULL;\par
36         head = temp;\par
37         {\cf19 return} head;\par
38     \}\par
39 \par
40     {\cf19 while} (cur->next != NULL)\par
41     \{\par
42         cur = cur->next;\par
43     \}\par
44     cur->next = temp;\par
45     temp->next = NULL;\par
46     {\cf19 return} head;\par
47 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/average_waiting_time.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/average_waiting_time.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/average_waiting_time.c}
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the average waiting time for the passengers. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include "../include/globals.h"}\par
{\f2 #include "../include/average_waiting_time.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

float {\b average_waiting_time} (float time_difference){\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the average waiting time for the passengers. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Ritika Arora - {\f2 ritikaarora@cmail.carleton.ca}\par
}}@detail The function is to measure the average time the passengers took to wait to get into the elevator.\par
The function has two static variables: counter and average_waiting_time, which stores the value from the previous runs of the function. Firstly, it checks if the input parameter is positive or negative. If it is negative, it will just return the average waiting time which is already stored in it without doing any calculations. If the input is a positive value , then it increments the counter and does the calculation to get the average waiting time.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i time_difference,the} \cell }{input parameter which is the difference between the time passenger arrived and the time passenger got into the elevator\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
float Returns the average waiting time. \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/cli_update.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/cli_update.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/cli_update.c}
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains declaration for cli_update function. Which displays elevator information. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "cli_update.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <stdlib.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b cli_update} (struct {\b elevator} arr[], unsigned int loop_time)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Updates the command line interface with the elevator data. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains declaration for cli_update function. Which displays elevator information. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v cli_update\:cli_update.c}
{\xe \v cli_update.c\:cli_update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void cli_update (struct {\b elevator}  {\i arr}[], unsigned int  {\i loop_time})}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Updates the command line interface with the elevator data. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears the screen and repopulates it with the updated elevator data. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i arr} \cell }{struct elevator that is an array of elevators. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
 \par
}}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if we are in unix/cygwin environment or windows environment\par
}{
Definition at line 19 of file cli_update.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20 \{\par
21 \par
24 {\cf21 #if __unix__ || __CYGWIN__}\par
25     system({\cf22 "clear"});\par
26 {\cf21 #elif _WIN32}\par
27     system({\cf22 "cls"});\par
28 {\cf21 #endif}\par
29     puts({\cf22 "Elevator\\tTime\\tFloor\\tPassengers\\tDirection\\tMoving\\t"});\par
30     {\cf18 int} current_floor = 0;\par
31     {\cf18 int} passenger = 0;\par
32     {\cf18 bool} direction_down = {\cf17 false};\par
33     {\cf18 bool} direction_up = {\cf17 false};\par
34     {\cf18 int} next_floor_time = 0;\par
35     {\cf18 bool} moving = {\cf17 false};\par
36     {\cf18 char} direction[5] = \{{\cf23 '\\0'},{\cf23 '\\0'},{\cf23 '\\0'},{\cf23 '\\0'},{\cf23 '\\0'}\};\par
37     {\cf18 char} move_or_no[4] = \{{\cf23 '\\0'},{\cf23 '\\0'},{\cf23 '\\0'},{\cf23 '\\0'},\};\par
38     {\cf19 for} ({\cf18 int} i = 0; i < elevator_count; i++)\par
39     \{\par
40         current_floor = arr[i].cur_floor;\par
41         passenger = arr[i].passenger_count;\par
42         direction_down = arr[i].direction_down;\par
43         direction_up = arr[i].direction_up;\par
44         next_floor_time = arr[i].timer;\par
45         moving = arr[i].moving;\par
46         {\cf19 if} (direction_up && direction_down)\par
47         \{\par
48             strcpy(direction, {\cf22 "ANY"});\par
49         \}\par
50         {\cf19 else} {\cf19 if} (direction_up)\par
51         \{\par
52             strcpy(direction, {\cf22 "UP"});\par
53         \}\par
54         {\cf19 else}\par
55         \{\par
56             strcpy(direction, {\cf22 "DOWN"});\par
57         \}\par
58         {\cf19 if} (moving)\par
59         \{\par
60             strcpy(move_or_no, {\cf22 "YES"});\par
61         \}\par
62         {\cf19 else}\par
63         \{\par
64             strcpy(move_or_no, {\cf22 "NO"});\par
65         \}\par
66         printf({\cf22 "%d\\t\\t%d\\t%d\\t%d\\t\\t%s\\t\\t%s\\n"}, i, next_floor_time, current_floor, passenger, direction, move_or_no);\par
67     \}\par
68     printf({\cf22 "SIMULATION TIME: %d\\n"},loop_time);\par
69 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/count_passenger.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/count_passenger.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/count_passenger.c}
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads line by line and counts the number of passenger based on passenger ID. When passenger ID equal to "911" it is considered as Emergency stop and wont be counted towards the passenger_count. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include "count_passenger.h"}\par
{\f2 #include "globals.h"}\par
{\f2 #include "structures.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b count_passenger} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads line by line and counts the number of passenger based on passenger ID. When passenger ID equal to "911" it is considered as Emergency stop and wont be counted towards the passenger_count. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Hariprasad Munusamy - {\f2 HariprasadMunusamy@cmail.carleton.ca} \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v count_passenger\:count_passenger.c}
{\xe \v count_passenger.c\:count_passenger}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int count_passenger ()}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Counts the passenger requests\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i No} \cell }{input parameter. The function uses the input file\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Returns count on successful execution and 0 if file doesn't exist. \par
}}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
es to store the number of emergency stop situations\par
}{
Definition at line 23 of file count_passenger.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24 \{\par
26     {\cf18 int} es=0;\par
27     passenger_count=0; {\cf20 //global variable stores the passenger count}\par
28     FILE *f;\par
29     {\cf18 char} a[10];\par
30     f=fopen({\cf22 "data/input.txt"},{\cf22 "r"});\par
31     {\cf19 if} (f==NULL) \par
32     \{ \par
33         printf({\cf22 "no input file exists"}); \par
34         {\cf19 return} 0; \par
35     \}\par
36     {\cf19 while}(fscanf(f,{\cf22 "%s"},a)!=EOF)\par
37     \{\par
38         {\cf19 if}((passenger_count==0)||(passenger_count%4)==0)\par
39         \{\par
40             {\cf19 if}(atoi(a)==911)\par
41             \{\par
42             es++;\par
43             \}\par
44         \}\par
45         passenger_count++;\par
46     \}\par
47     fclose(f);\par
48     passenger_count=passenger_count/4;\par
49     passenger_count=passenger_count-es;\par
50     {\cf19 return} passenger_count;  {\cf20 //returns the passenger count}\par
51 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/create_elevator_array.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/create_elevator_array.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/create_elevator_array.c}
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The function creates array for each elevator. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include "structures.h"}\par
{\f2 #include "create_elevator_array.h"}\par
{\f2 #include "globals.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b elevator} * {\b create_elevator_array} (int no_of_elevators)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The function creates array for each elevator. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Divyalakshmi Padmanaban - {\f2 Dpadm049@uottawa.ca} \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_elevator_array\:create_elevator_array.c}
{\xe \v create_elevator_array.c\:create_elevator_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b elevator}* create_elevator_array (int  {\i no_of_elevators})}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constraints checks the input parameter-no of elevators . No of elevators should be in range(1-100). Prints error message if the no of elevators is out of range and if memory allocation fails. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i The} \cell }{function takes number of lifts as input. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Returns the array of elevators. \par
}}}{
Definition at line 23 of file create_elevator_array.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24 \{\par
25     \par
26     {\cf19 if}((no_of_elevators==0)||(no_of_elevators>100)||(no_of_elevators<1)){\cf20 //checks if the input parameter is valid.}\par
27     \{\par
28         printf({\cf22 "Input parameter -Number of elevators entered is invalid \\n"});\par
29         {\cf19 return} 0;\par
30     \}\par
31     {\cf17 struct }elevator *ele;\par
32     ele=malloc (no_of_elevators * {\cf17 sizeof}({\cf17 struct} elevator));{\cf20 //creates memory for the input-no_of_elevators.}\par
33     {\cf19 if}(ele==NULL){\cf20 //checks if the memory allocation is success}\par
34     \{\par
35         printf({\cf22 "Memory allocation failed \\n"});\par
36         {\cf19 return} 0;\par
37     \}\par
38     {\cf19 else}\par
39     \{\par
40         \par
41         {\cf18 int} i;\par
42         {\cf18 int} j;\par
43         {\cf18 int} k;\par
44         {\cf19 for}(i=0;i<no_of_elevators;i++){\cf20 //initialising the array elements}\par
45         \{\par
46             ele[i].moving=0;\par
47             ele[i].between_floor=0;\par
48             ele[i].direction_up={\cf17 true};\par
49             ele[i].direction_down={\cf17 false};\par
50             ele[i].stop_at_floor=malloc(floor_count*{\cf17 sizeof}({\cf18 bool}));\par
51             {\cf19 for}(k=0;k<floor_count;k++)\par
52             \{\par
53                 ele[i].stop_at_floor[k]=0;\par
54             \}\par
55             ele[i].passenger_count=0;\par
56             ele[i].max_passenger=10;\par
57             ele[i].cur_floor=1;\par
58             ele[i].timer=0;\par
59             ele[i].passenger_arr = malloc(ele[i].max_passenger*{\cf17 sizeof}({\cf17 struct} passenger));\par
60             {\cf19 for} (j=0;j<ele[i].max_passenger;j++)\par
61             \{\par
62             ele[i].passenger_arr[j].in_elevator=0;\par
63             ele[i].passenger_arr[j].arrival_time=0;\par
64             ele[i].passenger_arr[j].arrival_floor=0;\par
65             ele[i].passenger_arr[j].dest_floor=0;\par
66             ele[i].passenger_arr[j].id=0;\par
67             \}\par
68             \par
69         \}\par
70     \par
71     {\cf19 return} ele;\par
72     \}\par
73     \par
74 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/create_floor_array.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/create_floor_array.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/create_floor_array.c}
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The function create arrays for every floor. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include "create_floor_array.h"}\par
{\f2 #include "globals.h"}\par
{\f2 #include "structures.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b passenger} ** {\b create_floor_array} (int no_of_floors)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The function create arrays for every floor. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Hariprasad Munusamy - {\f2 HariprasadMunusamy@cmail.carleton.ca} \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v create_floor_array\:create_floor_array.c}
{\xe \v create_floor_array.c\:create_floor_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b passenger}** create_floor_array (int  {\i no_of_floors})}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates array for every floor to store the passenger with requests.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i Gets} \cell }{the number of floors as input and creates a list of array for every floor.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
structure of arrays for the given number of floors. \par
}}}{
Definition at line 24 of file create_floor_array.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25  \{\par
26     {\cf19 if}(no_of_floors>floor_count)\par
27     \{\par
28         {\cf19 return} 0;\par
29     \}\par
30     {\cf17 struct }passenger **fla;\par
31     fla=({\cf17 struct }passenger **) calloc (no_of_floors,{\cf17 sizeof}({\cf17 struct} passenger*));\par
32     {\cf19 if}(fla==NULL)\par
33     \{\par
34         {\cf19 return} 0;\par
35     \}\par
36     {\cf19 else}\par
37     \{\par
38 \par
39     {\cf19 return} fla; {\cf20 //returns the pointer to a structure of array}\par
40     \}\par
41 \par
42 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/dynamic_simulation.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/dynamic_simulation.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/dynamic_simulation.c}
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains the definition of dynamic_simulation The function contains the algorithm for dynamic release of the program. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "functions.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include "dynamic_functions.h"}\par
{\f2 #include <time.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b dynamic_simulation} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function contains the working logic of the elevator array function for dynamic release. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains the definition of dynamic_simulation The function contains the algorithm for dynamic release of the program. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v dynamic_simulation\:dynamic_simulation.c}
{\xe \v dynamic_simulation.c\:dynamic_simulation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int dynamic_simulation (void )}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function contains the working logic of the elevator array function for dynamic release. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
@detail Contains the logic for the dynamic version. It contains the main logic loop for travel of elevators .The loop for placing passengers on floors and the complete flow of the program. Plus additional functional calls for the dynamic release.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
return 1 for successful completion. \par
}}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A boolean array that shows if elevator needs to stop at a floor. to pick a passenger.\par
Array conatining Elevators\par
Array to pointer of type passenger. Stores passengers on floors.\par
stores the passengers from input file.\par
main time counter\par
A queue of request made by passengers\par
}{
Definition at line 25 of file dynamic_simulation.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26 \{\par
27 \par
28     elevator_count = -1;\par
29     {\cf19 while} (elevator_count == -1)\par
30     \{\par
31         elevator_count = input_lifts(1);\par
32     \}\par
33     floor_count = -1;\par
34 \par
35     {\cf19 while} (floor_count == -1)\par
36     \{\par
37         floor_count = input_floors();\par
38     \}\par
39     {\cf18 bool} *stop_at_floor_global = ({\cf18 bool} *)calloc(floor_count, {\cf17 sizeof}({\cf18 bool})); \par
40     {\cf17 struct }elevator *elevator_arr = create_elevator_array(elevator_count);  \par
41     {\cf17 struct }passenger **floor_array = create_floor_array(floor_count);       \par
42     passenger_count = count_passenger();\par
43     {\cf17 struct }passenger *passenger_array = ({\cf17 struct }passenger *)calloc(passenger_count, {\cf17 sizeof}({\cf17 struct} passenger)); \par
44     read_passenger(passenger_array);\par
45     {\cf18 unsigned} {\cf18 int} t = 0;                       \par
46     {\cf17 struct }passenger *passenger_queue = NULL; \par
47 \par
48     {\cf18 int} prev_time_index = 0;\par
49 \par
50     {\cf18 bool} enable_realtime = {\cf17 false};  {\cf20 // Realtime or full-speed;}\par
51     {\cf18 bool} enable_user_input = {\cf17 true}; {\cf20 // ask user for input or not;}\par
52     {\cf18 bool} exit_main_loop = {\cf17 false};   {\cf20 // should we exit main loop if user orders simulation stop}\par
53     time_t start_time;\par
54     time_t end_time;\par
55     {\cf18 int} time_difference = 0;\par
56     {\cf18 int} divisor = 200;\par
57     {\cf19 while} (t < 2000) {\cf20 //86400 for whole day. Setting to 2000 since cli_update slows the program down.}\par
58     \{\par
59 \par
60         {\cf19 if} (t % divisor == 0 && enable_user_input)\par
61         \{                                                         {\cf20 //choices}\par
62             {\cf17 struct }passenger temp_passenger = \{0, 0, 0, 0, 0, 0\}; {\cf20 //To store the user entered passenger}\par
63             {\cf18 int} stop_input = 0;\par
64             {\cf18 bool} incorrect_choice = {\cf17 true};\par
65             {\cf19 while} (incorrect_choice)\par
66             \{\par
67                 puts({\cf22 "CHOSE AMONG THE FOLLOWING CHOICES:"});\par
68                 puts({\cf22 "Note this is repeated after every approximately 30 seconds in realtime mode"});\par
69                 puts({\cf22 "and 200 iterations in non-realtime mode. Simulation starts in non-realtime mode."});\par
70                 puts({\cf22 "1- Enter A Passenger Details."});\par
71                 puts({\cf22 "2- Create an Emergency stop."});\par
72                 puts({\cf22 "3- Enable/Disable realtime timer. "});\par
73                 puts({\cf22 "4- Do not ask for input again & Disable realtime timer."});\par
74                 puts({\cf22 "5- Do Nothing and continue."});\par
75                 puts({\cf22 "6- Exit the simulation."});\par
76                 {\cf18 int} user_choice = 0;\par
77                 {\cf19 while} (scanf({\cf22 "%d"}, &user_choice) == 0)\par
78                 \{\par
79                     puts({\cf22 "Incorrect Choice Please Try Again."});\par
80                     scanf({\cf22 "%*[\\n]"}); {\cf20 //discard all inputs until newline character}\par
81                 \}\par
82                 {\cf19 if} (user_choice > 0 && user_choice < 7)\par
83                 \{\par
84                     incorrect_choice = {\cf17 false}; {\cf20 //made correct choice no exit selection loop.}\par
85                     {\cf19 switch} (user_choice)\par
86                     \{\par
87 \par
88                     {\cf20 //1- Enter A Passenger Details.}\par
89                     {\cf19 case} 1:\par
90                         read_user_input_validate(&temp_passenger, t);\par
91                         passenger_queue = add_request_queue(passenger_queue, temp_passenger);\par
92                         {\cf19 break};\par
93                     {\cf20 //2- Create an Emergency stop.}\par
94                     {\cf19 case} 2:\par
95                         emergency_stop_handling(elevator_arr, &t);\par
96                         {\cf19 while} ((stop_input = input_after_stop()) == -1)\par
97                         \{ {\cf20 //loop until we get right input}\par
98                         \};\par
99                         {\cf19 if} (stop_input == 0)\par
100                         \{\par
101                             exit_main_loop = {\cf17 true};\par
102                         \}\par
103                         {\cf19 break};\par
104                     {\cf19 case} 3:\par
105                         enable_realtime = !enable_realtime; {\cf20 //toggle}\par
106                         {\cf19 if} (enable_realtime)\par
107                         \{\par
108                             divisor = 30;\par
109                         \}\par
110                         {\cf19 else}\par
111                         \{\par
112                             divisor = 200;\par
113                         \}\par
114                         printf({\cf22 "Set Real-time to : %d\\n"}, enable_realtime);\par
115                         {\cf19 break};\par
116                     {\cf19 case} 4:\par
117                         enable_realtime = {\cf17 false};\par
118                         enable_user_input = {\cf17 false};\par
119                         exit_main_loop = {\cf17 false};\par
120                         {\cf19 break};\par
121                     {\cf19 case} 5:\par
122                         {\cf19 break};\par
123                     {\cf19 case} 6:\par
124                         exit_main_loop = {\cf17 true};\par
125                         {\cf19 break};\par
126                     \}\par
127                 \}\par
128             \}\par
129             {\cf19 if} (exit_main_loop)\par
130             \{ {\cf20 //exit main loop;}\par
131                 {\cf19 break};\par
132             \}\par
133         \}\par
134         {\cf20 //set start time}\par
135         start_time = time(NULL);\par
136         {\cf20 //update the cli}\par
137         cli_update(elevator_arr, t);\par
138 \par
139         {\cf20 // Add passenger with current time step to queue}\par
140         {\cf19 for} ({\cf18 int} i_pass = prev_time_index; i_pass < passenger_count; i_pass++) {\cf20 //debugged works perfectly}\par
141         \{\par
142             {\cf19 if} (passenger_array[i_pass].arrival_time < t) {\cf20 //due to emergency stop we can skip some entries}\par
143             \{\par
144                 {\cf19 while} (passenger_array[prev_time_index].arrival_time < t && prev_time_index < passenger_count)\par
145                 \{\par
146                     prev_time_index++; {\cf20 //increment until we reach passenger with current or greater arrival_time then  t or reach end array.}\par
147                 \}\par
148             \}\par
149 \par
150             {\cf20 //Assume the passenger_array is sorted by arrival time.}\par
151             {\cf20 //prev_time_index prevents us from starting at previous index}\par
152             {\cf19 if} (passenger_array[i_pass].arrival_time == t)\par
153             \{\par
154 \par
155                 passenger_queue = add_request_queue(passenger_queue, passenger_array[i_pass]);\par
156                 prev_time_index++;\par
157             \}\par
158             {\cf19 else}\par
159             \{\par
160                 {\cf19 break};\par
161             \}\par
162         \}\par
163 \par
164         {\cf19 for} ({\cf18 int} i = 0; i < elevator_count; i++)\par
165         \{\par
166 \par
167             {\cf19 if} (is_lift_on_floor(elevator_arr, i))\par
168             \{\par
169                 {\cf18 int} drop_delay = 0;\par
170                 {\cf18 int} add_delay = 0;\par
171                 {\cf18 int} stop_change = elevator_arr[i].cur_floor - 1;\par
172                 {\cf19 if} (elevator_arr[i].passenger_count > 0)\par
173                 \{\par
174                     {\cf19 if} (elevator_arr[i].stop_at_floor[stop_change])\par
175                     \{ {\cf20 //remove any passengers that need to get off}\par
176                         drop_delay = passengers_drop(elevator_arr, i, elevator_arr[i].cur_floor, t);\par
177 \par
178                         {\cf19 if} (drop_delay > 0 || elevator_arr[i].passenger_count >= elevator_arr[i].max_passenger) {\cf20 //dropped passengers here or lift full}\par
179                         \{\par
180                             elevator_arr[i].stop_at_floor[stop_change] = {\cf17 false}; {\cf20 //dropped passengers here}\par
181                         \}\par
182                     \}\par
183                 \}\par
184                 {\cf19 if} (elevator_arr[i].passenger_count < elevator_arr[i].max_passenger)\par
185                 \{\par
186 \par
187                     add_delay = passengers_take_in(elevator_arr, i, floor_array, elevator_arr[i].cur_floor, t);\par
188                     elevator_arr[i].stop_at_floor[stop_change] = {\cf17 false};\par
189                     {\cf19 if} (floor_array[stop_change] == NULL)\par
190                     \{\par
191                         stop_at_floor_global[stop_change] = {\cf17 false};\par
192                     \}\par
193                     {\cf19 else}\par
194                     \{ {\cf20 //happens in case the lift gets full and their are still passengers on floor.}\par
195                         stop_at_floor_global[stop_change] = {\cf17 true};\par
196                     \}\par
197                     elevator_arr[i].stop_at_floor[stop_change] = {\cf17 false}; {\cf20 //lift has taken in or dropped passengers or is full and has completed it purpose on floor so we set to false.}\par
198                 \}\par
199                 {\cf18 int} total_delay = 2 * drop_delay + 2 * add_delay;\par
200                 elevator_arr[i].timer += total_delay;\par
201             \}\par
202 \par
203             {\cf17 struct }passenger *cur = passenger_queue;\par
204             {\cf18 int} index = 0;\par
205             {\cf19 while} (cur != NULL)\par
206             \{ {\cf20 //iterating over passenger queue}\par
207 \par
208                 {\cf18 bool} direction_up = (cur->arrival_floor <= cur->dest_floor); {\cf20 //passenger direction up}\par
209                 {\cf18 bool} direction_down = (cur->arrival_floor >= cur->dest_floor);\par
210                 {\cf19 if} (elevator_arr[i].direction_up == direction_up || elevator_arr[i].direction_down == direction_down)\par
211                 \{\par
212                     {\cf18 bool} is_above = cur->arrival_floor >= elevator_arr[i].cur_floor;\par
213                     {\cf18 bool} is_below = cur->arrival_floor <= elevator_arr[i].cur_floor;\par
214                     {\cf19 if} (elevator_arr[i].direction_up == is_above || elevator_arr[i].direction_down == is_below)\par
215                     \{ {\cf20 //elevator can pick this person up}\par
216                         {\cf17 struct }passenger temp = *cur;\par
217                         temp.next = NULL;                                 {\cf20 // removing this from passenger queue list}\par
218                         {\cf18 int} arrival_floor_index = temp.arrival_floor - 1; {\cf20 //-1 because of mismatch between array and input file}\par
219 \par
220                         add_passenger_floor(floor_array, arrival_floor_index, temp);\par
221                         stop_at_floor_global[temp.arrival_floor - 1] = {\cf17 true};\par
222                         passenger_queue = remove_passenger_queue(index, passenger_queue);\par
223                         index--; {\cf20 //list is smaller by one node.}\par
224                     \}\par
225                 \}\par
226 \par
227                 {\cf19 else}\par
228                 \{\par
229                     {\cf20 //is elevator at top floor}\par
230                     {\cf19 if} (elevator_arr[i].cur_floor == floor_count)\par
231                     \{\par
232                         {\cf20 //change direction to move down}\par
233                         {\cf18 int} success = moving_lift_down(elevator_arr, i);\par
234                         {\cf19 if} (success == -1)\par
235                         \{\par
236                             fprintf(stderr, {\cf22 "Could not change direction of elevator to Down. \\n"});\par
237                         \}\par
238                         {\cf17 struct }passenger temp = *cur;\par
239                         temp.next = NULL; {\cf20 // removing this from passenger queue list}\par
240 \par
241                         {\cf18 int} arrival_floor_index = temp.arrival_floor - 1;\par
242                         add_passenger_floor(floor_array, arrival_floor_index, temp);\par
243                         stop_at_floor_global[temp.arrival_floor - 1] = {\cf17 true};\par
244                         passenger_queue = remove_passenger_queue(index, passenger_queue);\par
245                         index--; {\cf20 //list is smaller by one node.}\par
246                     \}\par
247 \par
248                     {\cf20 //is elevator at ground floor. Can cause issues at start.}\par
249                     {\cf19 else} {\cf19 if} (elevator_arr[i].cur_floor == 1)\par
250                     \{\par
251                         {\cf20 //change direction to move up}\par
252                         moving_lift_up(elevator_arr, i);\par
253                         {\cf17 struct }passenger temp = *cur;\par
254                         temp.next = NULL; {\cf20 // removing this from passenger queue list}\par
255 \par
256                         {\cf18 int} arrival_floor_index = temp.arrival_floor - 1;\par
257                         add_passenger_floor(floor_array, arrival_floor_index, temp);\par
258                         stop_at_floor_global[temp.arrival_floor - 1] = {\cf17 true};\par
259                         passenger_queue = remove_passenger_queue(index, passenger_queue);\par
260                         index--; {\cf20 //list is smaller by one node.}\par
261                     \}\par
262 \par
263                     {\cf19 else} {\cf20 //passenger in lift go in opposite direction of the lift}\par
264                     \{\par
265                         {\cf20 // bool to check if elevator and passenger inside are travelling in same direction}\par
266                         {\cf18 bool} passenger_elevator_dir = {\cf17 false};\par
267                         {\cf19 for} ({\cf18 int} j = 0; j < elevator_arr[i].passenger_count; j++)\par
268                         \{\par
269                             {\cf19 if} (elevator_arr[i].passenger_arr[j].in_elevator)\par
270                             \{\par
271                                 {\cf18 bool} up = elevator_arr[i].passenger_arr[j].dest_floor > elevator_arr[i].passenger_arr[j].arrival_floor;\par
272                                 {\cf19 if} (elevator_arr[i].direction_up == up || elevator_arr[i].direction_down != up)\par
273                                 \{\par
274                                     passenger_elevator_dir = {\cf17 true};\par
275                                     {\cf19 break};\par
276                                 \}\par
277                             \}\par
278                         \}\par
279 \par
280                         {\cf20 //if no passengers are travelling in direction of lift change lift direction}\par
281                         {\cf19 if} (!passenger_elevator_dir)\par
282                         \{\par
283                             {\cf19 if} (elevator_arr[i].direction_up)\par
284                             \{\par
285                                 moving_lift_down(elevator_arr, i);\par
286                             \}\par
287                             {\cf19 else} {\cf19 if} (elevator_arr[i].direction_down)\par
288                             \{\par
289                                 moving_lift_up(elevator_arr, i);\par
290                             \}\par
291 \par
292                             {\cf17 struct }passenger temp = *cur;\par
293                             temp.next = NULL; {\cf20 // removing this from passenger queue list}\par
294 \par
295                             {\cf18 int} arrival_floor_index = temp.arrival_floor - 1;\par
296                             add_passenger_floor(floor_array, arrival_floor_index, temp);\par
297                             stop_at_floor_global[temp.arrival_floor - 1] = {\cf17 true};\par
298                             passenger_queue = remove_passenger_queue(index, passenger_queue);\par
299                             index--; {\cf20 //list is smaller by one node.}\par
300                         \}\par
301                     \}\par
302                 \}\par
303 \par
304                 {\cf20 //potential bug here due to deleting nodes in remove_passenger_queue}\par
305 \par
306                 cur = passenger_queue; {\cf20 //bug fix start}\par
307                 {\cf19 if} (cur != NULL)       {\cf20 //incase we deleted only node queue}\par
308                 \{\par
309                     {\cf19 for} ({\cf18 int} q_index = 0; q_index < index + 1; q_index++)\par
310                     \{\par
311                         cur = cur->next; {\cf20 //iterate until we reach the spot of deletion}\par
312                     \}\par
313                 \} {\cf20 //bug fix end}\par
314                 index++;\par
315 \par
316             \} {\cf20 //End of while loop iterating over queue}\par
317 \par
318             {\cf20 //move elevator here}\par
319             {\cf19 if} (elevator_arr[i].passenger_count > 0) {\cf20 //if there are passengers then lift needs to move}\par
320             \{\par
321                 elevator_arr[i].moving = {\cf17 true};\par
322                 elevator_arr[i].between_floor = {\cf17 true};\par
323             \}\par
324             {\cf19 else}\par
325             \{\par
326                 elevator_arr[i].moving = {\cf17 false}; {\cf20 //elevator is stopped and empty now}\par
327                 {\cf19 if} (elevator_arr[i].timer != 0)\par
328                 \{\par
329                     elevator_arr[i].between_floor = {\cf17 true}; {\cf20 //time for passenger to drop out.}\par
330                 \}\par
331                 {\cf19 else}\par
332                 \{\par
333                     elevator_arr[i].between_floor = {\cf17 false}; {\cf20 //elevator is stationary at current floor and can be used again.}\par
334                     {\cf19 if} (elevator_arr[i].cur_floor == 1)\par
335                     \{ {\cf20 //elevator at ground floor can only move up.}\par
336                         moving_lift_up(elevator_arr, i);\par
337                     \}\par
338                     {\cf19 else} {\cf19 if} (elevator_arr[i].cur_floor == floor_count) {\cf20 //At top floor and can only move down}\par
339                     \{\par
340                         moving_lift_down(elevator_arr, i);\par
341                     \}\par
342                     {\cf19 else}\par
343                     \{ {\cf20 //elevator in middle can go anywhere}\par
344                         elevator_arr[i].direction_up = {\cf17 true};\par
345                         elevator_arr[i].direction_down = {\cf17 true};\par
346                     \}\par
347                 \}\par
348             \}\par
349 \par
350             {\cf19 if} (elevator_arr[i].timer > 0)\par
351             \{\par
352                 elevator_arr[i].timer--;\par
353             \}\par
354             {\cf19 if} (elevator_arr[i].timer == 0)\par
355             \{ {\cf20 //we may need to move to another floor}\par
356                 {\cf18 int} current_floor = elevator_arr[i].cur_floor;\par
357                 {\cf18 bool} passengers_above = {\cf17 false}; {\cf20 //are there passengers above for drop or pickup?}\par
358                 {\cf18 bool} passengers_below = {\cf17 false}; {\cf20 //are there passengers below for drop or pickup?}\par
359                 {\cf19 if} (elevator_arr[i].direction_up)\par
360                 \{\par
361                     {\cf19 for} ({\cf18 int} k = current_floor; k < floor_count; k++) {\cf20 //start at current floor and search up}\par
362                     \{                                                 {\cf20 //k = current floor becuse searching up and array numbering starts from 0 so curent_floor as index is 1 floor above}\par
363                         {\cf20 //if we are below a floor and need to stop on it to drop a passenger.}\par
364                         {\cf18 bool} condition_a = elevator_arr[i].stop_at_floor[k];\par
365                         {\cf20 // if we are below a floor and neee to stop on it to pick a passenger.}\par
366                         {\cf18 bool} condition_b = stop_at_floor_global[k];\par
367                         {\cf19 if} (condition_a || condition_b)\par
368                         \{\par
369                             passengers_above = {\cf17 true};\par
370                             elevator_arr[i].stop_at_floor[k] = {\cf17 true};\par
371                             stop_at_floor_global[k] = {\cf17 false}; {\cf20 //lift assigned to this floor}\par
372                             {\cf19 break};\par
373                         \}\par
374                     \}\par
375                 \}\par
376                 {\cf19 else} {\cf19 if} (elevator_arr[i].direction_down)\par
377                 \{\par
378                     {\cf19 for} ({\cf18 int} k = current_floor - 2; k >= 0; k--)\par
379                     \{ {\cf20 //current_floor-2 because of array numbering and file numbering mismatch}\par
380                         {\cf20 //if we are above a floor and need to stop on it to drop passengers.}\par
381                         {\cf18 bool} condition_a = elevator_arr[i].stop_at_floor[k];\par
382                         {\cf20 //if we are above a floor and need to stop on it to pick a passenger.}\par
383                         {\cf18 bool} condition_b = stop_at_floor_global[k];\par
384                         {\cf19 if} (condition_a || condition_b)\par
385                         \{\par
386                             passengers_below = {\cf17 true};\par
387                             elevator_arr[i].stop_at_floor[k] = {\cf17 true};\par
388                             stop_at_floor_global[k] = {\cf17 false}; {\cf20 //lift assigned to this floor}\par
389 \par
390                             {\cf19 break};\par
391                         \}\par
392                     \}\par
393                 \}\par
394 \par
395                 {\cf19 if} (passengers_above)\par
396                 \{\par
397                     current_floor++;\par
398                 \}\par
399                 {\cf19 else} {\cf19 if} (passengers_below)\par
400                 \{\par
401                     current_floor--;\par
402                 \}\par
403                 elevator_arr[i].cur_floor = current_floor; {\cf20 //changed the floor}\par
404                 {\cf19 if} (elevator_arr[i].stop_at_floor[current_floor - 1] || stop_at_floor_global[current_floor - 1])\par
405                 \{ {\cf20 //do we need to stop at this floor}\par
406                     elevator_arr[i].moving = {\cf17 false};\par
407                     elevator_arr[i].between_floor = {\cf17 false};\par
408                     elevator_arr[i].stop_at_floor[current_floor - 1] = {\cf17 true}; {\cf20 //setting to true so that the lift stops at this floor}\par
409                                                                              {\cf20 //stop_at_floor_global[current_floor - 1] = false;}\par
410                 \}\par
411                 {\cf19 else} {\cf19 if} (passengers_above || passengers_below) {\cf20 //we do not need to stop at this floor.}\par
412                 \{\par
413                     elevator_arr[i].moving = {\cf17 true};\par
414                     elevator_arr[i].between_floor = {\cf17 true};\par
415                     elevator_arr[i].timer += 3; {\cf20 //add 3 sec till next floor}\par
416                 \}\par
417                 {\cf19 else}\par
418                 \{\par
419                     elevator_arr[i].moving = {\cf17 false};\par
420                     elevator_arr[i].between_floor = {\cf17 false};\par
421                 \}\par
422 \par
423                 {\cf19 if} (elevator_arr[i].direction_up && !passengers_above)\par
424                 \{ {\cf20 //if no passengers above then lift should change direction to down.}\par
425                     {\cf19 if} (current_floor != 1 && elevator_arr[i].passenger_count > 0)\par
426                     \{\par
427                         moving_lift_down(elevator_arr, i);\par
428                     \}\par
429                 \}\par
430                 {\cf19 else} {\cf19 if} (elevator_arr[i].direction_down && !passengers_below)\par
431                 \{\par
432                     {\cf19 if} (current_floor != floor_count && elevator_arr[i].passenger_count > 0)\par
433                     \{\par
434                         moving_lift_up(elevator_arr, i);\par
435                     \}\par
436                 \}\par
437             \}\par
438 \par
439         \} {\cf20 //end of elevator loop}\par
440 \par
441         end_time = time(NULL);\par
442         time_difference = 0;\par
443         {\cf19 while} (time_difference < 1 && enable_realtime)\par
444         \{ {\cf20 //wait one second}\par
445             end_time = time(NULL);\par
446             time_difference = end_time - start_time;\par
447         \}\par
448         t++;\par
449     \}\par
450     {\cf17 struct }passenger dummy;          {\cf20 //placeholder to pass to log. it should not be used.}\par
451     travel_log_file(dummy, 0, 0, 3); {\cf20 //choose mode to write max,avg time to file.}\par
452     {\cf19 return} 1;\par
453 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/emergency_stop_handling.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/emergency_stop_handling.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/emergency_stop_handling.c}
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
On account of emergency stop condition,All the elevators re moved to nearest floor. Passengers are removed from the elevators. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include "structures.h"}\par
{\f2 #include "globals.h"}\par
{\f2 #include "emergency_stop_handling.h"}\par
{\f2 #include "passengers_drop.h"}\par
{\f2 #include "cli_update.h"}\par
{\f2 #include <time.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b emergency_stop_handling} (struct {\b elevator} ele[], unsigned int *timer){\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
On account of emergency stop condition,All the elevators re moved to nearest floor. Passengers are removed from the elevators. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Divyalakshmi Padmanaban - {\f2 dpadm049@uottawa.ca} \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i The} \cell }{function takes elevator strucrure and the currect time index of the simulation\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The function returns nothing, takes all the lift to next floor and removes all passenger from elevator \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/globals.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/globals.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/globals.c}
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the global variables used in the program. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "globals.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b elevator_count}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b passenger_count}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b floor_count}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the global variables used in the program. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v elevator_count\:globals.c}
{\xe \v globals.c\:elevator_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int elevator_count}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total number of elevators in the bulding \par
}{
Definition at line 10 of file globals.c.}\par
}
{\xe \v floor_count\:globals.c}
{\xe \v globals.c\:floor_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int floor_count}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The floor count of the building \par
}{
Definition at line 16 of file globals.c.}\par
}
{\xe \v passenger_count\:globals.c}
{\xe \v globals.c\:passenger_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int passenger_count}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total number of passengers checked from the passengers file text \par
}{
Definition at line 13 of file globals.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/input_after_stop.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/input_after_stop.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/input_after_stop.c}
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When the simulation encounters a emergency stop situation input_after_stop function is invoked prompting for the user input. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "input_after_stop.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b input_after_stop} (){\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When the simulation encounters a emergency stop situation input_after_stop function is invoked prompting for the user input. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Hariprasad Munusamy - {\f2 HariprasadMunusamy@cmail.carleton.ca} \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
int Returns the user input (1 - to continue the simulation, 0 - to end the simulation) \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/input_floors.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/input_floors.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/input_floors.c}
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Obtains the floor count-Total number of floors in the building.Enables the user to enter the total number of floors in the building. based on availability. If none of those symptoms then patient is not admitted. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include "input_floors.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b input_floors} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Obtains the floor count-Total number of floors in the building.Enables the user to enter the total number of floors in the building. based on availability. If none of those symptoms then patient is not admitted. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Divyalakshmi Padmanaban - {\f2 Dpadm049@uottawa.ca} \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v input_floors\:input_floors.c}
{\xe \v input_floors.c\:input_floors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int input_floors (void )}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constraints If the floor count is 0 ,the function displays a error message and returns -1. If the floor count is less than 1(negative values) ,the function displays a error message and returns -1. If the floor count is greater than 100,the function displays a error message and returns -1. Floating point values entered considered to near integers. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The function accepts only values between 1 and 100 and returns the value;otherwise returns -1 and displays error message. \par
}}}{
Definition at line 20 of file input_floors.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21 \{\par
22     {\cf18 int} local_floor_count;\par
23 \par
24     printf({\cf22 "Enter the number of floors in the building-VALID INPUTS ARE FROM 1 TO 100\\n"});\par
25     puts({\cf22 "This Value should be greater than or equal to maximum floor number in input.txt file."});\par
26     scanf({\cf22 "%d"}, &local_floor_count);\par
27     {\cf20 //Following checks are performed to see if the entered value is erraneous.}\par
28     {\cf19 if} (local_floor_count == 0)\par
29     \{\par
30         printf({\cf22 "Entered number of floor invalid \\n"});\par
31         local_floor_count = -1;\par
32     \}\par
33     {\cf19 else} {\cf19 if} (local_floor_count < 1)\par
34     \{\par
35         printf({\cf22 "Entered number of floor is negative value and hence invalid \\n"});\par
36         local_floor_count = -1;\par
37     \}\par
38     {\cf19 else} {\cf19 if} (local_floor_count > 100)\par
39     \{\par
40         printf({\cf22 "Entered number of floor is greater than 100 and hence invalid \\n"});\par
41         local_floor_count = -1;\par
42     \}\par
43     {\cf20 //discards the values stored in stdin buffer.}\par
44     scanf({\cf22 "%*[^\\n]"});\par
45     {\cf19 return} local_floor_count;\par
46 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/input_lifts.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/input_lifts.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/input_lifts.c}
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the definition of input_lifts }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include "input_lifts.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b input_lifts} (int mode)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prompt the user to enter the number of lifts and takes the input. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the definition of input_lifts \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v input_lifts\:input_lifts.c}
{\xe \v input_lifts.c\:input_lifts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int input_lifts (int  {\i mode})}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prompt the user to enter the number of lifts and takes the input. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The function prompts the user to enter the number of lifts. If the lift count is less than one or greater than 100 (mode 0) or 10 (mode 1)the function displays an error message and returns -1. If the user enters anything other than a numeric entry. The function displays and error message, discards all inputs in stdin stream and returns -1. If the user enters numeric value. It accepts the only Whole number part of the entry and returns the entered whole number value.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i mode} \cell }{integer to select mode. mode 0 for 100 max, 1 for 10 max numbers.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
int Returns -1 if errors in input and integer if input is fine. \par
}}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
if the scanf does not read anything, clear from the stdin buffer and return -1\par
}{
Definition at line 28 of file input_lifts.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29 \{\par
30     {\cf18 int} temp;\par
31     puts({\cf22 "Please Enter an integer number for the number of Elevator in building."});\par
32     {\cf18 int} bounds = 0;\par
33     {\cf19 if} (mode == 0)\par
34     \{\par
35         puts({\cf22 "Valid entries are 1-100"});\par
36         bounds = 100;\par
37     \}\par
38     {\cf19 if} (mode == 1)\par
39     \{\par
40         puts({\cf22 "Valid entries are 1-10"});\par
41         bounds = 10;\par
42     \}\par
43     {\cf18 int} result = scanf({\cf22 "%d"}, &temp);\par
44     {\cf20 //printf("This is result %d \\n",result);}\par
45 \par
47     {\cf19 if} (result == 0)\par
48     \{\par
49         puts({\cf22 "Non-integer input entered. Please enter an integer.\\n"});\par
50         temp = -1;\par
51     \}\par
52     {\cf19 else} {\cf19 if} (temp < 1)\par
53     \{\par
54         puts({\cf22 "Value entered is less than 1"});\par
55         temp = -1;\par
56     \}\par
57     {\cf19 else} {\cf19 if} (temp > bounds)\par
58     \{\par
59         printf({\cf22 "Value entered is greater than %d\\n"}, bounds);\par
60         temp = -1;\par
61     \}\par
62     scanf({\cf22 "%*[^\\n]"}); {\cf20 //discards the leftover inputs in stdin buffer}\par
63     {\cf19 return} temp;\par
64 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/input_static_dynamic.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/input_static_dynamic.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/input_static_dynamic.c}
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prompts user for type of simulation they want to run. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../include/input_static_dynamic.h"}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b input_static_dynamic} (void){\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prompts user for type of simulation they want to run. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
@Author Ritika Arora\par
@detail Asks user the type of simulation he wants to run. For, static, he has to press 1 and for dynamic, he has to press 2. If 1 is entered by the user, then it will assign 0 to the local variable simulation_type. If 2 is entered, then it assigns 1 to the variable.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i void} \cell }{The function takes no inputs\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i simulation_type} \cell }{contains the value to be returned to decide which type of simulation runs.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
int Returns 0 for static simulation, 1 for dynamic simulation and -1 for invalid input. \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/is_lift_empty.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/is_lift_empty.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/is_lift_empty.c}
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if there is any space in the elevator to add more passengers. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include "../include/globals.h"}\par
{\f2 #include "../include/is_lift_empty.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b is_lift_empty} (struct {\b elevator} elevator_arr[], unsigned int index){\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if there is any space in the elevator to add more passengers. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Ritika Arora - {\f2 ritikaarora@cmail.carleton.ca}\par
}}@detail The function is to check if the elevator has any space to accommodate any other passenger or not. Firstly, it checks if the elevator number entered is less than the total number of elevators in the building. If it is greater than the total number of elevators in the building then it will give the error message and will return -1 Then, it checks if the number of the passengers in the elevator is more than or equal to the max number of passengers it can accommodate, then it prints that the lift is full and returns 0. Else, it returns 1.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i elevator_arr[]} \cell }{of type elevator structure, index of unsigned integer type The parameter elevator_arr[] will have all the details of the elevators and index is used to access any particular elevator\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
integer Returns -1 if errors in input and 1 if it has any space for any passenger and 0 if not. \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/is_lift_on_floor.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/is_lift_on_floor.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/is_lift_on_floor.c}
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the elevator structure's attribute between_floors. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include "globals.h"}\par
{\f2 #include "structures.h"}\par
{\f2 #include "is_lift_on_floor.h"}\par
{\f2 #include <stdlib.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b is_lift_on_floor} (struct {\b elevator} elev[], int index)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the elevator structure's attribute between_floors. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Divyalakshmi Padmanaban - {\f2 Dpadm049@uottawa.ca} \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v is_lift_on_floor\:is_lift_on_floor.c}
{\xe \v is_lift_on_floor.c\:is_lift_on_floor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int is_lift_on_floor (struct {\b elevator}  {\i elev}[], int  {\i index})}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
@ details Constraints Checks if the input parameter index(i.e)elevator number;is within the range of number of elevators in building. If index is greater than the number of elevators actually present in building;error message will be displayed and returns -1. Checks the condition of the lift . {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i The} \cell }{function takes the elevator structure and index. @ return The function 0 if lift is not on floor elso 0. \cell }
{\row }
}
}{
Definition at line 22 of file is_lift_on_floor.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23 \{\par
24     {\cf19 if} (index >= elevator_count) {\cf20 //check on the input parameter which cannot be more than the number of elevators in the building.}\par
25     \{\par
26         fprintf(stderr, {\cf22 "Input parameter -Index is greater than the array ele[]-------- %d >= %d \\n"}, index, elevator_count);\par
27         exit(1);\par
28         {\cf19 return} -1;\par
29     \}\par
30 \par
31     {\cf19 if} (elev[index].between_floor == 1) {\cf20 //check on the value of between_floors that makes evident if the lift is on floor or in between.}\par
32     \{\par
33         {\cf19 return} 0;\par
34     \}\par
35     {\cf19 else} {\cf19 if} (elev[index].between_floor == 0)\par
36     \{\par
37         {\cf19 return} 1;\par
38     \}\par
39     {\cf19 else}\par
40     \{\par
41         fprintf(stderr, {\cf22 "Incorrect elev[index].between_floor Value : %d \\n"}, elev[index].between_floor);\par
42         exit(1);\par
43     \}\par
44 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/main.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/main.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/main.c}
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function executes the Static and Dynamic version of elevator. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "functions.h"}\par
{\f2 #include "dynamic_functions.h"}\par
{\f2 #include "simulations.h"}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function serves as an entry point into the program. Allows choice between the two versions. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function executes the Static and Dynamic version of elevator. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal \par
 \par
Hariprasad Munusamy \par
Divyalakshmi Padmanaban \par
Ritika Arora \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:main.c}
{\xe \v main.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (void )}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function serves as an entry point into the program. Allows choice between the two versions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This finction asks the user for selection between static and dynamic simulation of elevator.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This function returns an integer 0 (Zero) upon successful execution. \par
}}}{
Definition at line 26 of file main.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27 \{\par
28     {\cf18 int} selection = -1;\par
29     {\cf18 int} status = 0;\par
30     {\cf19 while} (selection == -1)\par
31     \{ {\cf20 //the function returns -1 on wrong input.}\par
32         selection = input_static_dynamic();\par
33     \}\par
34     {\cf19 switch} (selection)\par
35     \{\par
36     {\cf19 case} 0:\par
37         status = static_simulation();\par
38         {\cf19 break};\par
39     {\cf19 case} 1:\par
40         status = dynamic_simulation();\par
41         {\cf19 break};\par
42     \}\par
43     {\cf19 if} (status == 1)\par
44     \{\par
45         printf({\cf22 "Simulation Run Succesfully.\\n"});\par
46     \}\par
47     {\cf19 return} status;\par
48 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/max_waiting_time.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/max_waiting_time.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/max_waiting_time.c}
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the maximum waiting time for the passengers. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include "../include/globals.h"}\par
{\f2 #include "../include/max_waiting_time.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

float {\b max_waiting_time} (float time_difference){\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the maximum waiting time for the passengers. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Ritika Arora - {\f2 ritikaarora@cmail.carleton.ca}\par
}}@detail The function is to measure the maximum time the passengers took to wait to get into the elevator. The function compares the time given as an input with static variable max_time. If the input time is greater than the max time , then that time value is stored as max time.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i time_difference,the} \cell }{input parameter which is the difference between the time passenger arrived and the time passenger got into the elevator\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
float Returns the maximum waiting time. \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/moving_lift_down.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/moving_lift_down.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/moving_lift_down.c}
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the definition of moving_lift_down }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include "structures.h"}\par
{\f2 #include "globals.h"}\par
{\f2 #include "moving_lift_down.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b moving_lift_down} (struct {\b elevator} elevator_arr[], unsigned int index)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
changes the direction of lift to down. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the definition of moving_lift_down \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v moving_lift_down\:moving_lift_down.c}
{\xe \v moving_lift_down.c\:moving_lift_down}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int moving_lift_down (struct {\b elevator}  {\i elevator_arr}[], unsigned int  {\i index})}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
changes the direction of lift to down. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function takes as input an elevator array and changes the direction of the elevator at the specified index position. sets {\b elevator.direction_up} to false and {\b elevator.direction_down} to true. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i elevator_arr[]} \cell }{an array of type struct elevator \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
int Returns -1 if errors in function call and 1 if function runs properly. \par
}}}{
Definition at line 25 of file moving_lift_down.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26 \{\par
27 \par
28     {\cf19 if} (index >= elevator_count)\par
29     \{\par
30         fprintf(stderr, {\cf22 "index >= elevator_arr size. %d >= %d \\n"}, index, elevator_count);\par
31         {\cf19 return} -1;\par
32     \}\par
33     elevator_arr[index].direction_up = {\cf17 false};\par
34     elevator_arr[index].direction_down = {\cf17 true};\par
35     {\cf19 return} 1;\par
36 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/moving_lift_up.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/moving_lift_up.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/moving_lift_up.c}
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To set the direction of the lift to Upward direction. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include "../include/globals.h"}\par
{\f2 #include "../include/structures.h"}\par
{\f2 #include "../include/moving_lift_up.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b moving_lift_up} (struct {\b elevator} elevator_arr[], unsigned int index){\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To set the direction of the lift to Upward direction. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Ritika Arora - {\f2 ritikaarora@cmail.carleton.ca}\par
}}@detail The function is to set the direction of the lift to UP. The function calls with two param[in] an array of elevators of elevator type and an integer value which indicated the index as well as the number of the elevator in the building. The function firstly checks, if the elevator number entered is less than the total number of elevators in the building. If it is greater than the total number of elevators in the building then it will give the error message and will return -1 Otherwise, it will set the direction of that particular elevator to UP.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
integer value 1 if everything goes well. \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/passengers_drop.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/passengers_drop.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/passengers_drop.c}
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The function takes in the elevator_array. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "passengers_drop.h"}\par
{\f2 #include <assert.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include "globals.h"}\par
{\f2 #include "structures.h"}\par
{\f2 #include "travel_log_file.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b passengers_drop} (struct {\b elevator} elevator_arr[], int index, int cur_floor, unsigned int event_time)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The function takes in the elevator_array. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Hariprasad Munusamy - {\f2 HariprasadMunusamy@cmail.carleton.ca} \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v passengers_drop\:passengers_drop.c}
{\xe \v passengers_drop.c\:passengers_drop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int passengers_drop (struct {\b elevator}  {\i elevator_arr}[], int  {\i index}, int  {\i cur_floor}, unsigned int  {\i event_time})}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the passenger from the floor and the elevator array.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i elevator_arr} \cell }{array of struct elevators \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i index} \cell }{index of the elevator to operate on \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i cur_floor} \cell }{the current floor of the elevator \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i event_time} \cell }{the time this event happened.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The function return the number of passengers dropped. \par
}}}{
Definition at line 27 of file passengers_drop.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28 \{\par
29 \par
30     assert(index <= elevator_count);\par
31     assert(cur_floor <= floor_count);\par
32     assert(cur_floor == elevator_arr[index].cur_floor);\par
33 \par
34     {\cf18 int} passenger_dropped = 0;\par
35     {\cf18 int} max_passenger = elevator_arr[index].max_passenger;\par
36     {\cf20 //Loop to iterate the overall passengers in the elevator}\par
37     {\cf19 for} ({\cf18 int} i = 0; i < max_passenger; i++)\par
38     \{\par
39         {\cf18 bool} in_elevator = elevator_arr[index].passenger_arr[i].in_elevator;\par
40         {\cf19 if} (elevator_arr[index].passenger_arr[i].dest_floor == cur_floor && in_elevator)\par
41         \{\par
42             elevator_arr[index].passenger_arr[i].in_elevator = {\cf17 false}; {\cf20 //setting the status}\par
43             elevator_arr[index].passenger_count--;\par
44             passenger_dropped++;\par
45             {\cf17 struct }passenger temp = elevator_arr[index].passenger_arr[i];\par
46             travel_log_file(temp, event_time, index, 1); {\cf20 //choose mode to write to travel_log as we are removing passenger.}\par
47         \}\par
48     \}\par
49     {\cf19 return} passenger_dropped;\par
50 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/passengers_take_in.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/passengers_take_in.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/passengers_take_in.c}
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the definition of passengers_take_in }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "passengers_take_in.h"}\par
{\f2 #include <assert.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include "globals.h"}\par
{\f2 #include "remove_passenger_floor.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include "travel_log_file.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b passengers_take_in} (struct {\b elevator} elevator_arr[], int index, struct {\b passenger} *{\b floor_arr}[], int cur_floor, unsigned int event_time)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the definition of passengers_take_in \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v passengers_take_in\:passengers_take_in.c}
{\xe \v passengers_take_in.c\:passengers_take_in}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int passengers_take_in (struct {\b elevator}  {\i elevator_arr}[], int  {\i index}, struct {\b passenger} *  {\i floor_arr}[], int  {\i cur_floor}, unsigned int  {\i event_time})}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function removes adds a passenger from a queue to the elevator_array\par
This function take in an elevator, index of the elevator, array of floor and current_floor. and removes the passenger from the floor and adds it to elevator passenger array. \par
 {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i index} \cell }{int value that specifies the index of the elevator. index start at 0. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i elevator_arr} \cell }{pointer to elevator array. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i floor_arr} \cell }{array of pointers to passengers on floor. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i cur_florr} \cell }{int value that specifies the current floor. As described in elevator so start at 1 and equal to max_floor_count. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i event_time} \cell }{unsigned int the time the event has happened. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
return the number of passengers added to the elevator. \par
}}}{
Definition at line 28 of file passengers_take_in.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29 \{\par
30 \par
31     assert(index < elevator_count && index >= 0);\par
32     assert(cur_floor <= floor_count && cur_floor > 0);\par
33     assert(cur_floor == elevator_arr[index].cur_floor); {\cf20 //? test the case that both elevator and passenger are at same floor.}\par
34 \par
35     {\cf18 int} floor_index = cur_floor - 1; {\cf20 //input file floor start from 1 while floor array is indexed from 0 so this is needed}\par
36     {\cf18 int} passenger_capacity = elevator_arr[index].max_passenger;\par
37     {\cf18 int} passenger_added = 0;\par
38 \par
39     {\cf19 for} ({\cf18 int} i = 0; i < passenger_capacity; i++)\par
40     \{\par
41 \par
42         {\cf19 if} (!(elevator_arr[index].passenger_arr[i].in_elevator))\par
43         \{\par
44 \par
45             {\cf19 if} (floor_arr[floor_index] != NULL && elevator_arr[index].passenger_count < passenger_capacity)\par
46             \{\par
47                 {\cf17 struct }passenger temp = *(floor_arr[floor_index]);\par
48                 elevator_arr[index].passenger_arr[i] = temp;\par
49                 elevator_arr[index].passenger_arr[i].in_elevator = {\cf17 true};\par
50                 elevator_arr[index].passenger_count++;\par
51                 elevator_arr[index].stop_at_floor[temp.dest_floor - 1] = {\cf17 true}; {\cf20 //stop at this floor from drop off}\par
52                 passenger_added++;\par
53                 travel_log_file(*(floor_arr[floor_index]), event_time, index, 2); {\cf20 //choose mode to calculate avg,max times.}\par
54                 remove_passenger_floor(floor_arr, cur_floor);\par
55             \}\par
56             {\cf19 else}\par
57             \{\par
58                 {\cf19 break};\par
59             \}\par
60         \}\par
61     \}\par
62     {\cf19 return} passenger_added;\par
63 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/read_passenger.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/read_passenger.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/read_passenger.c}
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the input file for passenger id,arrival time,starting floor and destination floor. Enables to read the data from file and store in a structure of maximum capacity 100. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include "read_passenger.h"}\par
{\f2 #include "structures.h"}\par
{\f2 #include "globals.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b read_passenger} (struct {\b passenger} p[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the input file for passenger id,arrival time,starting floor and destination floor. Enables to read the data from file and store in a structure of maximum capacity 100. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Divyalakshmi Padmanaban - {\f2 Dpadm049@uottawa.ca} \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v read_passenger\:read_passenger.c}
{\xe \v read_passenger.c\:read_passenger}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void read_passenger (struct {\b passenger}  {\i p}[])}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constraints If the file does not exists ,the function displays a error message. The input file is checked for valid values for passenegr id in range (1-99) and print error message if the values are out of range. The input file is checked for valid values for arrival time in range (1-150)and print error message if the values are out of range The input file is checked for valid values for arrival floor in range (1-100)and print error message if the values are out of range The input file is checked for valid values for destination floor in range (1-100)and print error message if the values are out of range {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i No} \cell }{input parameter. The function uses the input file \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the function returns void \par
}}}{
Definition at line 25 of file read_passenger.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26 \{\par
27 \par
28     FILE *f;\par
29     {\cf18 int} i = 0;\par
30     {\cf18 int} count = 0;\par
31     f = fopen({\cf22 "data/input.txt"}, {\cf22 "r"});\par
32     {\cf18 int} fd = fileno(f); {\cf20 //fileno function returns the mode of file.}\par
33     {\cf19 if} (fd == -1)\par
34     \{\par
35         printf({\cf22 "Error - input file\\n"});\par
36         exit(1); {\cf20 //program ends incase of absence of file in specified path.}\par
37     \}\par
38     {\cf19 if} (f == NULL)\par
39     \{\par
40         printf({\cf22 "Error -opening the file\\n"});\par
41         exit(1); {\cf20 //program ends incase of error in opening the  input file.}\par
42     \}\par
43 \par
44     {\cf19 if} (NULL != f)\par
45     \{\par
46         {\cf18 int} size;\par
47         fseek(f, 0, SEEK_END);\par
48         size = ftell(f);\par
49 \par
50         {\cf19 if} (0 == size)\par
51         \{\par
52             printf({\cf22 "Input file is empty\\n"});\par
53             exit(1);\par
54         \}\par
55     \}\par
56     rewind(f);\par
57 \par
58     {\cf18 char} c[100];\par
59     {\cf19 while} (fscanf(f, {\cf22 "%s"}, c) != EOF)\par
60     \{\par
61 \par
62         {\cf20 //  printf("%s",c,);}\par
63 \par
64         {\cf19 if} (count == 0)\par
65         \{\par
66 \par
67             p[i].id = atoi(c);\par
68             count++;\par
69             {\cf19 if} ((p[i].{\cf18 id} == 0) || (p[i].{\cf18 id} < 1))\par
70             \{\par
71                 printf({\cf22 "p[%d] -Passenger ID column contains invalid data in  file (i.e)%d\\n"}, i, p[i].{\cf18 id});\par
72                 exit(1); {\cf20 //program ends incase of erraneous data.}\par
73             \}\par
74         \}\par
75 \par
76         {\cf19 else} {\cf19 if} (count == 1)\par
77         \{\par
78 \par
79             p[i].arrival_time = atoi(c);\par
80             count++;\par
81             {\cf19 if} ((p[i].arrival_time == 0) || (p[i].arrival_time > 86400) || (p[i].arrival_time < 1))\par
82             \{\par
83                 printf({\cf22 "p[%d].-arrival_time column contains invalid data in file (i.e)%d\\n"}, i, p[i].arrival_time);\par
84                 exit(1); {\cf20 //program ends incase of erraneous data.}\par
85             \}\par
86         \}\par
87         {\cf19 else} {\cf19 if} (count == 2)\par
88         \{\par
89 \par
90             p[i].arrival_floor = atoi(c);\par
91             count++;\par
92             {\cf19 if} ((p[i].arrival_floor == 0) || (p[i].arrival_floor > floor_count) || (p[i].arrival_floor < 1))\par
93             \{\par
94                 printf({\cf22 "p[%d].arrival_floor column contains invalid data  in file (i.e)%d\\n"}, i, p[i].arrival_floor);\par
95                 exit(1); {\cf20 //program ends incase of erraneous data.}\par
96             \}\par
97         \}\par
98         {\cf19 else} {\cf19 if} (count == 3)\par
99         \{\par
100             {\cf20 //printf("\\n%s\\n",c);}\par
101             p[i].dest_floor = atoi(c);\par
102             count = 0;\par
103             {\cf19 if} ((p[i].dest_floor == 0) || (p[i].dest_floor > 100) || (p[i].dest_floor < 1))\par
104             \{\par
105                 printf({\cf22 "p[%d].dest_floor column contains invalid data in  file (i.e)%d\\n"}, i, p[i].dest_floor);\par
106                 exit(1); {\cf20 //program ends incase of erraneous data.}\par
107             \}\par
108             i++;\par
109         \}\par
110     \}\par
111 \par
112     printf({\cf22 "read_passenger is executed-Size of array of structure passenger is %d \\n"}, i);\par
113     fclose(f);\par
114     printf({\cf22 "Input file is closed-read_passenger function\\n"});\par
115 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/read_user_input_validate.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/read_user_input_validate.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/read_user_input_validate.c}
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the input from the console and adds to the passenger struct after validating. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../include/read_user_input_validate.h"}\par
{\f2 #include "../include/globals.h"}\par
{\f2 #include "../include/structures.h"}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b read_user_input_validate} (struct {\b passenger} *passenger_info, unsigned int timer){\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the input from the console and adds to the passenger struct after validating. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Ritika Arora\par
}}Reads the passenger details from the user console. Validates the inputs given. Then, adds the inputs taken to the passenger structure\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i passenger_info} \cell }{pointer to the passenger structure containing data of the passenger. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i timer} \cell }{to get the time of simulation and store as time of arrival\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
void returns nothing \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/remove_passenger_floor.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/remove_passenger_floor.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/remove_passenger_floor.c}
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the passenger details from floor specified. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "remove_passenger_floor.h"}\par
{\f2 #include "structures.h"}\par
{\f2 #include <assert.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include "globals.h"}\par
{\f2 #include "stdio.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b remove_passenger_floor} (struct {\b passenger} *floordetails[], int cur_floor)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the passenger details from floor specified. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Divyalakshmi Padmanaban - {\f2 Dpadm049@uottawa.ca} \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v remove_passenger_floor\:remove_passenger_floor.c}
{\xe \v remove_passenger_floor.c\:remove_passenger_floor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int remove_passenger_floor (struct {\b passenger} *  {\i floordetails}[], int  {\i cur_floor})}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constraints The program terminates if the input parameter cur_floor(passenger details for this particular floor has to be deleted)is erraneous. (i.e)cur_floor must be within the range 1-100 and less than the floor_count(Total number of floors in the building ) {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i The} \cell }{function takes passenger structure and current floor. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Returns 1 on successful deletion of passenger details from specified floor. \par
}}}{
Definition at line 23 of file remove_passenger_floor.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24 \{\par
25 \par
26     assert(cur_floor > 0); {\cf20 //checks the value of cur_floor ;if it returns 0- terminates the program}\par
27     assert(cur_floor <= floor_count);\par
28     {\cf17 static} {\cf18 int} no_of_passengers_removed = 0;\par
29     {\cf18 int} floor_index = cur_floor - 1; {\cf20 //needed because floor array strt at 0 and elevator floor at 1}\par
30     {\cf17 struct }passenger *temp;\par
31     temp = floordetails[floor_index];\par
32     floordetails[floor_index] = floordetails[floor_index]->next;\par
33     printf({\cf22 "Passenger %d from floor %d removed. No of passengers removed: %d\\n"}, temp->id, cur_floor, ++no_of_passengers_removed);\par
34     free(temp);\par
35     {\cf19 return} 1;\par
36 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/remove_passenger_queue.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/remove_passenger_queue.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/remove_passenger_queue.c}
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the definition of {\b remove_passenger_queue()}. This function is removes a passenger from the passenger_queue. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "remove_passenger_queue.h"}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <assert.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b passenger} * {\b remove_passenger_queue} (int index, struct {\b passenger} *head)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the definition of {\b remove_passenger_queue()}. This function is removes a passenger from the passenger_queue. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal. \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v remove_passenger_queue\:remove_passenger_queue.c}
{\xe \v remove_passenger_queue.c\:remove_passenger_queue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b passenger}* remove_passenger_queue (int  {\i index}, struct {\b passenger} *  {\i head})}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function removes a passenger from a queue at given index and frees the memory\par
The function remomves and frees memory location at given index. if the given index is at the head the head is removed and new head is returned. If index is greater then length of queue the function causes program to exit.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i index} \cell }{int value that points to index of queue to return. indices start at 0. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i head} \cell }{pointer to head of the queue.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
return the value of the head. head will point to new value head if index is 0. \par
}}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
< Precondition that head not be Null\par
< Precondition that index not be negative\par
< stores the current position of pointer to be used in while loop\par
Iterate through the queue until we are one node behind the node we want to delete. Or next node is null. Set next of previous node to next node and store the node to delete in temp. use free to delete current node.\par
This is precondition checks if index was greater than queue length and this cannot be done at start as we do not know total length of queue at begining. the check is cur->nect != NULL as we stop before element to be removed. if cur->next = NULL it means the index is greater than length as we are at end list and should have stopped at index-1.\par
}{
Definition at line 25 of file remove_passenger_queue.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26 \{\par
27 \par
28     assert(head != NULL); \par
29     assert(index > -1);   \par
30 \par
31     {\cf17 static} {\cf18 int} removal_count = 0;\par
32     {\cf17 struct }passenger *temp = NULL;\par
33     {\cf17 struct }passenger *cur = head; \par
34     {\cf19 if} (index == 0)\par
35     \{\par
36         temp = head;\par
37         head = head->next;\par
38         printf({\cf22 "The passenger Removed from cue is:%d count is:%d \\n."}, temp->id, ++removal_count);\par
39         free(temp);\par
40         {\cf19 return} head;\par
41     \}\par
42     {\cf19 else}\par
43     \{\par
44         {\cf18 int} i = 0;\par
45 \par
52         {\cf19 while} (i < index - 1 && cur->next != NULL)\par
53         \{\par
54             cur = cur->next;\par
55             i++;\par
56         \}\par
57 \par
63         assert(cur->next != NULL);\par
64 \par
65         temp = cur->next;\par
66         cur->next = temp->next;\par
67         printf({\cf22 "The passenger Removed from cue is:%d count is:%d \\n."}, temp->id, ++removal_count);\par
68         free(temp);\par
69     \}\par
70     {\cf19 return} head;\par
71 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/static_simulation.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/static_simulation.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/static_simulation.c}
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains the definition of static_simulation The function contains the algorithm for static release of the program. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "functions.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <stdbool.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b static_simulation} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function contains the working logic of the elevator array function for static release. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains the definition of static_simulation The function contains the algorithm for static release of the program. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v static_simulation\:static_simulation.c}
{\xe \v static_simulation.c\:static_simulation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int static_simulation (void )}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function contains the working logic of the elevator array function for static release. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
@detail Contains the logic for the static release. It contains the main logic loop for travel of elevators. The loop for placing passengers on floors and the complete flow of the program.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
return 1 for succesfull completion. \par
}}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A boolean array that shows if elevator needs to stop at a floor. to pick a passenger.\par
Array conatining Elevators\par
Array to pointer of type passenger. Stores passengers on floors.\par
stores the passengers from input file.\par
main time counter\par
A queue of request made by passengers\par
}{
Definition at line 21 of file static_simulation.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22 \{\par
23 \par
24     elevator_count = -1;\par
25     {\cf19 while} (elevator_count == -1)\par
26     \{\par
27         elevator_count = input_lifts(0);\par
28     \}\par
29     floor_count = -1;\par
30 \par
31     {\cf19 while} (floor_count == -1)\par
32     \{\par
33         floor_count = input_floors();\par
34     \}\par
35     {\cf18 bool} *stop_at_floor_global = ({\cf18 bool} *)calloc(floor_count, {\cf17 sizeof}({\cf18 bool})); \par
36     {\cf17 struct }elevator *elevator_arr = create_elevator_array(elevator_count);  \par
37     {\cf17 struct }passenger **floor_array = create_floor_array(floor_count);       \par
38     passenger_count = count_passenger();\par
39     {\cf17 struct }passenger *passenger_array = ({\cf17 struct }passenger *)calloc(passenger_count, {\cf17 sizeof}({\cf17 struct} passenger)); \par
40     read_passenger(passenger_array);\par
41     {\cf18 unsigned} {\cf18 int} t = 0;                       \par
42     {\cf17 struct }passenger *passenger_queue = NULL; \par
43 \par
44     {\cf18 int} prev_time_index = 0;\par
45 \par
46     {\cf19 while} (t < 1000) {\cf20 //86400 for whole day}\par
47     \{\par
48 \par
49         {\cf20 // Add passenger with current time step to queue}\par
50         {\cf19 for} ({\cf18 int} i_pass = prev_time_index; i_pass < passenger_count; i_pass++) {\cf20 //debugged works perfectly}\par
51         \{\par
52 \par
53             {\cf20 //Assume the passenger_array is sorted by arrival time.}\par
54             {\cf20 //prev_time_index prevents us from starting at previous index}\par
55             {\cf19 if} (passenger_array[i_pass].arrival_time == t)\par
56             \{\par
57 \par
58                 passenger_queue = add_request_queue(passenger_queue, passenger_array[i_pass]);\par
59                 prev_time_index++;\par
60             \}\par
61             {\cf19 else}\par
62             \{\par
63                 {\cf19 break};\par
64             \}\par
65         \}\par
66 \par
67         {\cf19 for} ({\cf18 int} i = 0; i < elevator_count; i++)\par
68         \{\par
69 \par
70             {\cf19 if} (is_lift_on_floor(elevator_arr, i))\par
71             \{\par
72                 {\cf18 int} drop_delay = 0;\par
73                 {\cf18 int} add_delay = 0;\par
74                 {\cf18 int} stop_change = elevator_arr[i].cur_floor - 1;\par
75                 {\cf19 if} (elevator_arr[i].passenger_count > 0)\par
76                 \{\par
77                     {\cf19 if} (elevator_arr[i].stop_at_floor[stop_change])\par
78                     \{ {\cf20 //remove any passengers that need to get off}\par
79                         drop_delay = passengers_drop(elevator_arr, i, elevator_arr[i].cur_floor, t);\par
80 \par
81                         {\cf19 if} (drop_delay > 0 || elevator_arr[i].passenger_count >= elevator_arr[i].max_passenger) {\cf20 //dropped passengers here or lift full}\par
82                         \{\par
83                             elevator_arr[i].stop_at_floor[stop_change] = {\cf17 false}; {\cf20 //dropped passengers here}\par
84                         \}\par
85                     \}\par
86                 \}\par
87                 {\cf19 if} (elevator_arr[i].passenger_count < elevator_arr[i].max_passenger)\par
88                 \{\par
89 \par
90                     add_delay = passengers_take_in(elevator_arr, i, floor_array, elevator_arr[i].cur_floor, t);\par
91                     elevator_arr[i].stop_at_floor[stop_change] = {\cf17 false};\par
92                     {\cf19 if} (floor_array[stop_change] == NULL)\par
93                     \{\par
94                         stop_at_floor_global[stop_change] = {\cf17 false};\par
95                     \}\par
96                     {\cf19 else}\par
97                     \{ {\cf20 //happens in case the lift gets full and their are still passengers on floor.}\par
98                         stop_at_floor_global[stop_change] = {\cf17 true};\par
99                     \}\par
100                     elevator_arr[i].stop_at_floor[stop_change] = {\cf17 false}; {\cf20 //lift has taken in or dropped passengers or is full and has completed it purpose on floor so we set to false.}\par
101                 \}\par
102                 {\cf18 int} total_delay = 2 * drop_delay + 2 * add_delay;\par
103                 elevator_arr[i].timer += total_delay;\par
104             \}\par
105 \par
106             {\cf17 struct }passenger *cur = passenger_queue;\par
107             {\cf18 int} index = 0;\par
108             {\cf19 while} (cur != NULL)\par
109             \{ {\cf20 //iterating over passenger queue}\par
110 \par
111                 {\cf18 bool} direction_up = (cur->arrival_floor <= cur->dest_floor); {\cf20 //passenger direction up}\par
112                 {\cf18 bool} direction_down = (cur->arrival_floor >= cur->dest_floor);\par
113                 {\cf19 if} (elevator_arr[i].direction_up == direction_up || elevator_arr[i].direction_down == direction_down)\par
114                 \{\par
115                     {\cf18 bool} is_above = cur->arrival_floor >= elevator_arr[i].cur_floor;\par
116                     {\cf18 bool} is_below = cur->arrival_floor <= elevator_arr[i].cur_floor;\par
117                     {\cf19 if} (elevator_arr[i].direction_up == is_above || elevator_arr[i].direction_down == is_below)\par
118                     \{ {\cf20 //elevator can pick this person up}\par
119                         {\cf17 struct }passenger temp = *cur;\par
120                         temp.next = NULL;                                 {\cf20 // removing this from passenger queue list}\par
121                         {\cf18 int} arrival_floor_index = temp.arrival_floor - 1; {\cf20 //-1 because of mismatch between array and input file}\par
122 \par
123                         add_passenger_floor(floor_array, arrival_floor_index, temp);\par
124                         stop_at_floor_global[temp.arrival_floor - 1] = {\cf17 true};\par
125                         passenger_queue = remove_passenger_queue(index, passenger_queue);\par
126                         index--; {\cf20 //list is smaller by one node.}\par
127                     \}\par
128                 \}\par
129 \par
130                 {\cf19 else}\par
131                 \{\par
132                     {\cf20 //is elevator at top floor}\par
133                     {\cf19 if} (elevator_arr[i].cur_floor == floor_count)\par
134                     \{\par
135                         {\cf20 //change direction to move down}\par
136                         {\cf18 int} success = moving_lift_down(elevator_arr, i);\par
137                         {\cf19 if} (success == -1)\par
138                         \{\par
139                             fprintf(stderr, {\cf22 "Could not change direction of elevator to Down. \\n"});\par
140                         \}\par
141                         {\cf17 struct }passenger temp = *cur;\par
142                         temp.next = NULL; {\cf20 // removing this from passenger queue list}\par
143 \par
144                         {\cf18 int} arrival_floor_index = temp.arrival_floor - 1;\par
145                         add_passenger_floor(floor_array, arrival_floor_index, temp);\par
146                         stop_at_floor_global[temp.arrival_floor - 1] = {\cf17 true};\par
147                         passenger_queue = remove_passenger_queue(index, passenger_queue);\par
148                         index--; {\cf20 //list is smaller by one node.}\par
149                     \}\par
150 \par
151                     {\cf20 //is elevator at ground floor. Can cause issues at start.}\par
152                     {\cf19 else} {\cf19 if} (elevator_arr[i].cur_floor == 1)\par
153                     \{\par
154                         {\cf20 //change direction to move up}\par
155                         moving_lift_up(elevator_arr, i);\par
156                         {\cf17 struct }passenger temp = *cur;\par
157                         temp.next = NULL; {\cf20 // removing this from passenger queue list}\par
158 \par
159                         {\cf18 int} arrival_floor_index = temp.arrival_floor - 1;\par
160                         add_passenger_floor(floor_array, arrival_floor_index, temp);\par
161                         stop_at_floor_global[temp.arrival_floor - 1] = {\cf17 true};\par
162                         passenger_queue = remove_passenger_queue(index, passenger_queue);\par
163                         index--; {\cf20 //list is smaller by one node.}\par
164                     \}\par
165 \par
166                     {\cf19 else} {\cf20 //passenger in lift go in opposite direction of the lift}\par
167                     \{\par
168                         {\cf20 // bool to check if elevator and passenger inside are travelling in same direction}\par
169                         {\cf18 bool} passenger_elevator_dir = {\cf17 false};\par
170                         {\cf19 for} ({\cf18 int} j = 0; j < elevator_arr[i].passenger_count; j++)\par
171                         \{\par
172                             {\cf19 if} (elevator_arr[i].passenger_arr[j].in_elevator)\par
173                             \{\par
174                                 {\cf18 bool} up = elevator_arr[i].passenger_arr[j].dest_floor > elevator_arr[i].passenger_arr[j].arrival_floor;\par
175                                 {\cf19 if} (elevator_arr[i].direction_up == up || elevator_arr[i].direction_down != up)\par
176                                 \{\par
177                                     passenger_elevator_dir = {\cf17 true};\par
178                                     {\cf19 break};\par
179                                 \}\par
180                             \}\par
181                         \}\par
182 \par
183                         {\cf20 //if no passengers are travelling in direction of lift change lift direction}\par
184                         {\cf19 if} (!passenger_elevator_dir)\par
185                         \{\par
186                             {\cf19 if} (elevator_arr[i].direction_up)\par
187                             \{\par
188                                 moving_lift_down(elevator_arr, i);\par
189                             \}\par
190                             {\cf19 else} {\cf19 if} (elevator_arr[i].direction_down)\par
191                             \{\par
192                                 moving_lift_up(elevator_arr, i);\par
193                             \}\par
194 \par
195                             {\cf17 struct }passenger temp = *cur;\par
196                             temp.next = NULL; {\cf20 // removing this from passenger queue list}\par
197 \par
198                             {\cf18 int} arrival_floor_index = temp.arrival_floor - 1;\par
199                             add_passenger_floor(floor_array, arrival_floor_index, temp);\par
200                             stop_at_floor_global[temp.arrival_floor - 1] = {\cf17 true};\par
201                             passenger_queue = remove_passenger_queue(index, passenger_queue);\par
202                             index--; {\cf20 //list is smaller by one node.}\par
203                         \}\par
204                     \}\par
205                 \}\par
206 \par
207                 {\cf20 //potential bug here due to deleting nodes in remove_passenger_queue}\par
208 \par
209                 cur = passenger_queue; {\cf20 //bug fix start}\par
210                 {\cf19 if} (cur != NULL)       {\cf20 //incase we deleted only node queue}\par
211                 \{\par
212                     {\cf19 for} ({\cf18 int} q_index = 0; q_index < index + 1; q_index++)\par
213                     \{\par
214                         cur = cur->next; {\cf20 //iterate until we reach the spot of deletion}\par
215                     \}\par
216                 \} {\cf20 //bug fix end. bug fixed}\par
217                 index++;\par
218 \par
219             \} {\cf20 //End of while loop iterating over queue}\par
220 \par
221             {\cf20 //move elevator here}\par
222             {\cf19 if} (elevator_arr[i].passenger_count > 0) {\cf20 //if there are passengers then lift needs to move}\par
223             \{\par
224                 elevator_arr[i].moving = {\cf17 true};\par
225                 elevator_arr[i].between_floor = {\cf17 true};\par
226             \}\par
227             {\cf19 else}\par
228             \{\par
229                 elevator_arr[i].moving = {\cf17 false}; {\cf20 //elevator is stopped and empty now}\par
230                 {\cf19 if} (elevator_arr[i].timer != 0)\par
231                 \{\par
232                     elevator_arr[i].between_floor = {\cf17 true}; {\cf20 //time for passenger to drop out.}\par
233                 \}\par
234                 {\cf19 else}\par
235                 \{\par
236                     elevator_arr[i].between_floor = {\cf17 false}; {\cf20 //elevator is stationary at current floor and can be used again.}\par
237                     {\cf19 if} (elevator_arr[i].cur_floor == 1)\par
238                     \{ {\cf20 //elevator at ground floor can only move up.}\par
239                         moving_lift_up(elevator_arr, i);\par
240                     \}\par
241                     {\cf19 else} {\cf19 if} (elevator_arr[i].cur_floor == floor_count) {\cf20 //At top floor and can only move down}\par
242                     \{\par
243                         moving_lift_down(elevator_arr, i);\par
244                     \}\par
245                     {\cf19 else}\par
246                     \{ {\cf20 //elevator in middle can go anywhere}\par
247                         elevator_arr[i].direction_up = {\cf17 true};\par
248                         elevator_arr[i].direction_down = {\cf17 true};\par
249                     \}\par
250                 \}\par
251             \}\par
252 \par
253             {\cf19 if} (elevator_arr[i].timer > 0)\par
254             \{\par
255                 elevator_arr[i].timer--;\par
256             \}\par
257             {\cf19 if} (elevator_arr[i].timer == 0)\par
258             \{ {\cf20 //we may need to move to another floor}\par
259                 {\cf18 int} current_floor = elevator_arr[i].cur_floor;\par
260                 {\cf18 bool} passengers_above = {\cf17 false}; {\cf20 //are there passengers above for drop or pickup?}\par
261                 {\cf18 bool} passengers_below = {\cf17 false}; {\cf20 //are there passengers below for drop or pickup?}\par
262                 {\cf19 if} (elevator_arr[i].direction_up)\par
263                 \{\par
264                     {\cf19 for} ({\cf18 int} k = current_floor; k < floor_count; k++) {\cf20 //start at current floor and search up}\par
265                     \{                                                 {\cf20 //k = current floor becuse searching up and array numbering starts from 0 so curent_floor as index is 1 floor above}\par
266                         {\cf20 //if we are below a floor and need to stop on it to drop a passenger.}\par
267                         {\cf18 bool} condition_a = elevator_arr[i].stop_at_floor[k];\par
268                         {\cf20 // if we are below a floor and neee to stop on it to pick a passenger.}\par
269                         {\cf18 bool} condition_b = stop_at_floor_global[k];\par
270                         {\cf19 if} (condition_a || condition_b)\par
271                         \{\par
272                             passengers_above = {\cf17 true};\par
273                             elevator_arr[i].stop_at_floor[k] = {\cf17 true};\par
274                             stop_at_floor_global[k] = {\cf17 false}; {\cf20 //lift assigned to this floor}\par
275                             {\cf19 break};\par
276                         \}\par
277                     \}\par
278                 \}\par
279                 {\cf19 else} {\cf19 if} (elevator_arr[i].direction_down)\par
280                 \{\par
281                     {\cf19 for} ({\cf18 int} k = current_floor - 2; k >= 0; k--)\par
282                     \{ {\cf20 //current_floor-2 because of array numbering and file numbering mismatch}\par
283                         {\cf20 //if we are above a floor and need to stop on it to drop passengers.}\par
284                         {\cf18 bool} condition_a = elevator_arr[i].stop_at_floor[k];\par
285                         {\cf20 //if we are above a floor and need to stop on it to pick a passenger.}\par
286                         {\cf18 bool} condition_b = stop_at_floor_global[k];\par
287                         {\cf19 if} (condition_a || condition_b)\par
288                         \{\par
289                             passengers_below = {\cf17 true};\par
290                             elevator_arr[i].stop_at_floor[k] = {\cf17 true};\par
291                             stop_at_floor_global[k] = {\cf17 false}; {\cf20 //lift assigned to this floor}\par
292 \par
293                             {\cf19 break};\par
294                         \}\par
295                     \}\par
296                 \}\par
297 \par
298                 {\cf19 if} (passengers_above)\par
299                 \{\par
300                     current_floor++;\par
301                 \}\par
302                 {\cf19 else} {\cf19 if} (passengers_below)\par
303                 \{\par
304                     current_floor--;\par
305                 \}\par
306                 elevator_arr[i].cur_floor = current_floor; {\cf20 //changed the floor}\par
307                 {\cf19 if} (elevator_arr[i].stop_at_floor[current_floor - 1] || stop_at_floor_global[current_floor - 1])\par
308                 \{ {\cf20 //do we need to stop at this floor}\par
309                     elevator_arr[i].moving = {\cf17 false};\par
310                     elevator_arr[i].between_floor = {\cf17 false};\par
311                     elevator_arr[i].stop_at_floor[current_floor - 1] = {\cf17 true}; {\cf20 //setting to true so that the lift stops at this floor}\par
312                 \}\par
313                 {\cf19 else} {\cf19 if} (passengers_above || passengers_below) {\cf20 //we do not need to stop at this floor.}\par
314                 \{\par
315                     elevator_arr[i].moving = {\cf17 true};\par
316                     elevator_arr[i].between_floor = {\cf17 true};\par
317                     elevator_arr[i].timer += 3; {\cf20 //add 3 sec till next floor}\par
318                 \}\par
319                 {\cf19 else}\par
320                 \{\par
321                     elevator_arr[i].moving = {\cf17 false};\par
322                     elevator_arr[i].between_floor = {\cf17 false};\par
323                 \}\par
324 \par
325                 {\cf19 if} (elevator_arr[i].direction_up && !passengers_above)\par
326                 \{ {\cf20 //if no passengers above then lift should change direction to down.}\par
327                     {\cf19 if} (current_floor != 1 && elevator_arr[i].passenger_count > 0)\par
328                     \{\par
329                         moving_lift_down(elevator_arr, i);\par
330                     \}\par
331                 \}\par
332                 {\cf19 else} {\cf19 if} (elevator_arr[i].direction_down && !passengers_below)\par
333                 \{\par
334                     {\cf19 if} (current_floor != floor_count && elevator_arr[i].passenger_count > 0)\par
335                     \{\par
336                         moving_lift_up(elevator_arr, i);\par
337                     \}\par
338                 \}\par
339             \}\par
340 \par
341         \} {\cf20 //end of elevator loop}\par
342 \par
343         t++;\par
344     \}\par
345     {\cf17 struct }passenger dummy;          {\cf20 //placeholder to pass to log. it should not be used.}\par
346     travel_log_file(dummy, 0, 0, 3); {\cf20 //choose mode to write max,avg time to file.}\par
347     {\cf19 return} 1;\par
348 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/src/travel_log_file.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/src/travel_log_file.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/src/travel_log_file.c}
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the deifintion of {\b travel_log_file()} this function writes useful logs about the travel of the passengers. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "travel_log_file.h"}\par
{\f2 #include "structures.h"}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include "average_waiting_time.h"}\par
{\f2 #include "max_waiting_time.h"}\par
{\f2 #include <stdbool.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b travel_log_file} (struct {\b passenger} traveler, unsigned int event_time, int elevator_index, int mode)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the deifintion of {\b travel_log_file()} this function writes useful logs about the travel of the passengers. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v travel_log_file\:travel_log_file.c}
{\xe \v travel_log_file.c\:travel_log_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void travel_log_file (struct {\b passenger}  {\i traveler}, unsigned int  {\i event_time}, int  {\i elevator_index}, int  {\i mode})}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function generates and updates the outputput files for data processin\par
This function generates the output file waiting_times.txt and travel_log.txt which contain the average and max waiting time, and the user_id,elevator_id, passenger arrival time passenger leaving time.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i traveler} \cell }{struct containing details about the passenger \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i event_time} \cell }{the time the event to be recorded happened. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i elevator_index} \cell }{the index of the elevator the passenger was in. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i mode} \cell }{1 for writing to travel_log.txt, 2 for calculating average and max time,3 for writing waiting_times.txt log file)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
does not return an value \par
}}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This keeps track if the output path file is being opened for first time\par
relative path to the travel_log.txt file path\par
}{
Definition at line 30 of file travel_log_file.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 31 \{\par
32 \par
33     {\cf17 static} {\cf18 bool} first_call = {\cf17 true};                             \par
34     {\cf18 char} *travel_file_path = {\cf22 "data/travel_log.txt"};            \par
35     {\cf18 char} *waiting_times_files_path = {\cf22 "data/waiting_times.txt"}; {\cf20 //relative path to waiting_times.txt file path}\par
36     FILE *f;\par
37     {\cf18 float} diff;\par
38     {\cf19 switch} (mode)\par
39     \{\par
40 \par
41     {\cf19 case} 1: {\cf20 //This case is to write to travel_log file}\par
42         {\cf19 if} (first_call)\par
43         \{\par
44             f = fopen(travel_file_path, {\cf22 "w+"});\par
45             {\cf19 if} (f == NULL)\par
46             \{\par
47                 fprintf(stderr, {\cf22 "Could not create/open travel_log.txt file.\\n"});\par
48                 exit(-1);\par
49             \}\par
50             first_call = {\cf17 false};\par
51             fprintf(f, {\cf22 "Passenger_ID,Elevator_ID,Passenger_In_time,Passenger_Entry_floor,Passenger_Out_time,Passenger_Exit_floor\\n"});\par
52         \}\par
53         {\cf19 else}\par
54         \{\par
55             f = fopen(travel_file_path, {\cf22 "a+"});\par
56             {\cf19 if} (f == NULL)\par
57             \{\par
58                 fprintf(stderr, {\cf22 "Could not create/open travel_log.txt file.\\n"});\par
59                 exit(-1);\par
60             \}\par
61         \}\par
62 \par
63         {\cf18 int} {\cf18 id} = traveler.id;\par
64         {\cf18 int} in_time = traveler.arrival_time;\par
65         {\cf18 int} in_floor = traveler.arrival_floor;\par
66         {\cf18 int} out_floor = traveler.dest_floor;\par
67         fprintf(f, {\cf22 "%d,%d,%d,%d,%d,%d\\n"}, {\cf18 id}, elevator_index, in_time, in_floor, event_time, out_floor);\par
68         fflush(f);\par
69         fclose(f);\par
70         {\cf19 break};\par
71     {\cf19 case} 2:\par
72         {\cf20 //This case is to calculate max and average wait time.}\par
73 \par
74         diff = event_time - traveler.arrival_time;\par
75         {\cf19 if} (diff < 0.0)\par
76         \{\par
77             fprintf(stderr, {\cf22 "Negative time difference.\\n"});\par
78             exit(-1);\par
79         \}\par
80         average_waiting_time(diff);\par
81         max_waiting_time(diff);\par
82         {\cf19 break};\par
83     {\cf19 case} 3: {\cf20 //This case is to write to waiting time}\par
84         f = fopen(waiting_times_files_path, {\cf22 "w+"});\par
85         {\cf19 if} (f == NULL)\par
86         \{\par
87             fprintf(stderr, {\cf22 "Could not create waiting_times.txt file.\\n"});\par
88             exit(-1);\par
89         \}\par
90         {\cf18 float} avg_time = average_waiting_time(-1.0);\par
91         {\cf18 float} max_time = max_waiting_time(-1.0);\par
92         fprintf(f, {\cf22 "Average Waiting time of Passenger: %f\\n"}, avg_time);\par
93         fprintf(f, {\cf22 "Maximum Waiting time of Passenger: %f\\n"}, max_time);\par
94         fflush(f);\par
95         fclose(f);\par
96         {\cf19 break};\par
97     {\cf19 default}:\par
98         fprintf(stderr, {\cf22 "Incorrect mode selection."});\par
99         exit(-1);\par
100     \}\par
101 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/test/include/test_functions.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/test/include/test_functions.h}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/test/include/test_functions.h}
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the function declarations for all the test_functions }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_add_request_queue} (void){\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_average_waiting_time} (void){\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_count_passenger} (void){\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_create_elevator_array} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_create_floor_array} (void){\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_input_after_stop} (void){\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_input_floors} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_input_lifts} (void){\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_is_lift_empty} (void){\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_is_lift_on_floor} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_max_waiting_time} (void){\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_moving_lift_down} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function test the function moving_lift_down. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_passenger_take_in} (void){\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_read_passenger} (void){\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_remove_passenger_queue} (void){\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_cli_update} (void){\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_add_passenger_floor} (void){\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_remove_passenger_floor} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
tests the remove_passenger function. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the function declarations for all the test_functions \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v test_create_elevator_array\:test_functions.h}
{\xe \v test_functions.h\:test_create_elevator_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_create_elevator_array (void )}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calls the function {\b create_elevator_array.c} with valid parameters. Prints the PASS /FAIL status ,by accessing the return from create_elevator_array function. results_create_elevator_array file contains the results. \par
}{
Definition at line 20 of file test_create_elevator_array.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21 \{\par
22     {\cf17 struct }elevator *elev;\par
23     printf({\cf22 "results_create_elevator_array file contains output \\n\\n "});\par
24     FILE *fp;\par
25     fp = freopen({\cf22 "test/results/results_create_elevator_array.txt"}, {\cf22 "w+"}, stdout);\par
26     elev = create_elevator_array(4);\par
27     {\cf19 if} (elev != NULL)\par
28     \{\par
29         printf({\cf22 "PASS;Input Parameter:Valid;array of structure elevator could be accessed .\\n"});\par
30     \}\par
31     {\cf19 else}\par
32     \{\par
33         printf({\cf22 "FAIL;Input Parameter:Valid;array of structure elevator could not be accessed .\\n"});\par
34     \}\par
35     fflush(fp);\par
36     fclose(fp);\par
37 \}\par
}
}
{\xe \v test_input_floors\:test_functions.h}
{\xe \v test_functions.h\:test_input_floors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_input_floors (void )}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calls the function {\b input_floors.c} with input from input_input_floors.txt. Prints the PASS /FAIL status ,by accessing the return from input_floors function. results_input_floors file contains the results. \par
}{
Definition at line 20 of file test_input_floors.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21 \{\par
22     FILE *test_results;\par
23     test_results = fopen({\cf22 "test/results/results_input_floors.txt"}, {\cf22 "w"});\par
24     freopen({\cf22 "test/data/input_input_floors.txt"}, {\cf22 "r"}, stdin);\par
25     {\cf18 int} arr[13];\par
26     arr[0] = input_floors();\par
27     arr[1] = input_floors();\par
28     arr[2] = input_floors();\par
29     arr[3] = input_floors();\par
30     arr[4] = input_floors();\par
31     arr[5] = input_floors();\par
32     arr[6] = input_floors();\par
33     arr[7] = input_floors();\par
34     arr[8] = input_floors();\par
35     arr[9] = input_floors();\par
36     arr[10] = input_floors();\par
37     arr[11] = input_floors();\par
38     arr[12] = input_floors();\par
39     arr[13] = input_floors();\par
40 \par
41     {\cf18 int} case_id = 0;\par
42     {\cf20 //Test case 1 -input abcd}\par
43 \par
44     {\cf19 if} (arr[0] == -1)\par
45     \{\par
46         {\cf18 char} temp[100];\par
47         sprintf(temp, {\cf22 "PASS: Input: abcd, Expected Output: -1, Output: %d .\\n"},\par
48                 arr[0]);\par
49         printf(temp);\par
50         fprintf(test_results, temp);\par
51     \}\par
52 \par
53     {\cf19 else}\par
54     \{\par
55         {\cf18 char} temp[100];\par
56         sprintf(temp, {\cf22 "FAIL: Input: abcd, Expected Output: -1, Output: %d .\\n"},\par
57                 arr[0]);\par
58         printf(temp);\par
59         fprintf(test_results, temp);\par
60     \}\par
61     {\cf20 //Test case 2- input abcd123}\par
62     {\cf19 if} (arr[1] == -1)\par
63     \{\par
64         {\cf18 char} temp[100];\par
65         sprintf(temp, {\cf22 "PASS: Input: abcd123, Expected Output: -1, Output: %d .\\n"},\par
66                 arr[0]);\par
67         printf(temp);\par
68         fprintf(test_results, temp);\par
69     \}\par
70 \par
71     {\cf19 else}\par
72     \{\par
73         {\cf18 char} temp[100];\par
74         sprintf(temp, {\cf22 "FAIL: Input: abcd123, Expected Output: -1, Output: %d .\\n"},\par
75                 arr[0]);\par
76         printf(temp);\par
77         fprintf(test_results, temp);\par
78     \}\par
79     {\cf20 //Test case 3- input 0}\par
80     {\cf19 if} (arr[2] == -1)\par
81     \{\par
82         {\cf18 char} temp[100];\par
83         sprintf(temp, {\cf22 "PASS: Input: 0, Expected Output: -1, Output: %d .\\n"},\par
84                 arr[0]);\par
85         printf(temp);\par
86         fprintf(test_results, temp);\par
87     \}\par
88 \par
89     {\cf19 else}\par
90     \{\par
91         {\cf18 char} temp[100];\par
92         sprintf(temp, {\cf22 "FAIL: Input: 0, Expected Output: -1, Output: %d .\\n"},\par
93                 arr[0]);\par
94         printf(temp);\par
95         fprintf(test_results, temp);\par
96     \}\par
97     {\cf20 //Test case 4- input -100}\par
98     {\cf19 if} (arr[2] == -1)\par
99     \{\par
100         {\cf18 char} temp[100];\par
101         sprintf(temp, {\cf22 "PASS: Input: -100, Expected Output: -1, Output: %d .\\n"},\par
102                 arr[0]);\par
103         printf(temp);\par
104         fprintf(test_results, temp);\par
105     \}\par
106 \par
107     {\cf19 else}\par
108     \{\par
109         {\cf18 char} temp[100];\par
110         sprintf(temp, {\cf22 "FAIL: Input: -100, Expected Output: -1, Output: %d .\\n"},\par
111                 arr[0]);\par
112         printf(temp);\par
113         fprintf(test_results, temp);\par
114     \}\par
115 \par
116     {\cf20 //Test case 5 -input 101}\par
117     {\cf19 if} (arr[4] == -1)\par
118     \{\par
119         {\cf18 char} temp[100];\par
120         sprintf(temp, {\cf22 "PASS: Input: 101, Expected Output: -1, Output: %d .\\n"},\par
121                 arr[4]);\par
122         printf(temp);\par
123         fprintf(test_results, temp);\par
124     \}\par
125     {\cf19 else}\par
126     \{\par
127         {\cf18 char} temp[100];\par
128         sprintf(temp, {\cf22 "FAIL: Input: 101, Expected Output: -1, Output: %d .\\n"},\par
129                 arr[4]);\par
130         printf(temp);\par
131         fprintf(test_results, temp);\par
132     \}\par
133 \par
134     {\cf20 //Test case 6 -input 1}\par
135     {\cf19 if} (arr[5] == 1)\par
136     \{\par
137         {\cf18 char} temp[100];\par
138         sprintf(temp, {\cf22 "PASS: Input: 1, Expected Output: 1, Output: %d .\\n"},\par
139                 arr[5]);\par
140         printf(temp);\par
141         fprintf(test_results, temp);\par
142     \}\par
143     {\cf19 else}\par
144     \{\par
145         {\cf18 char} temp[100];\par
146         sprintf(temp, {\cf22 "FAIL: Input: 1, Expected Output: 1, Output: %d .\\n"},\par
147                 arr[5]);\par
148         printf(temp);\par
149         fprintf(test_results, temp);\par
150     \}\par
151 \par
152     {\cf20 //Test case 7 -input 100}\par
153     case_id = 6;\par
154     {\cf19 if} (arr[case_id] == 100)\par
155     \{\par
156         {\cf18 char} temp[100];\par
157         sprintf(temp, {\cf22 "PASS: Input: 100, Expected Output: 100, Output: %d .\\n"},\par
158                 arr[case_id]);\par
159         printf(temp);\par
160         fprintf(test_results, temp);\par
161     \}\par
162     {\cf19 else}\par
163     \{\par
164         {\cf18 char} temp[100];\par
165         sprintf(temp, {\cf22 "FAIL: Input: 100, Expected Output: 100, Output: %d .\\n"},\par
166                 arr[case_id]);\par
167         printf(temp);\par
168         fprintf(test_results, temp);\par
169     \}\par
170 \par
171     {\cf20 //Test case 8 input 50}\par
172     case_id = 7;\par
173     {\cf19 if} (arr[case_id] == 50)\par
174     \{\par
175         {\cf18 char} temp[100];\par
176         sprintf(temp, {\cf22 "PASS: Input: 50, Expected Output: 50, Output: %d .\\n"},\par
177                 arr[case_id]);\par
178         printf(temp);\par
179         fprintf(test_results, temp);\par
180     \}\par
181     {\cf19 else}\par
182     \{\par
183         {\cf18 char} temp[100];\par
184         sprintf(temp, {\cf22 "FAIL: Input: 50, Expected Output: 50, Output: %d .\\n"},\par
185                 arr[case_id]);\par
186         printf(temp);\par
187         fprintf(test_results, temp);\par
188     \}\par
189 \par
190     {\cf20 //Test case 9 input 23.3}\par
191     case_id = 8;\par
192     {\cf19 if} (arr[case_id] == 23)\par
193     \{\par
194         {\cf18 char} temp[100];\par
195         sprintf(temp, {\cf22 "PASS: Input: 23.3, Expected Output: 23, Output: %d .\\n"},\par
196                 arr[case_id]);\par
197         printf(temp);\par
198         fprintf(test_results, temp);\par
199     \}\par
200     {\cf19 else}\par
201     \{\par
202         {\cf18 char} temp[100];\par
203         sprintf(temp, {\cf22 "FAIL: Input: 23.3, Expected Output: 23, Output: %d .\\n"},\par
204                 arr[case_id]);\par
205         printf(temp);\par
206         fprintf(test_results, temp);\par
207     \}\par
208 \par
209     {\cf20 //Test case 10 input 0.9}\par
210     case_id = 9;\par
211     {\cf19 if} (arr[case_id] == -1)\par
212     \{\par
213         {\cf18 char} temp[100];\par
214         sprintf(temp, {\cf22 "PASS: Input: 0.9, Expected Output: -1, Output: %d .\\n"},\par
215                 arr[case_id]);\par
216         printf(temp);\par
217         fprintf(test_results, temp);\par
218     \}\par
219     {\cf19 else}\par
220     \{\par
221         {\cf18 char} temp[100];\par
222         sprintf(temp, {\cf22 "FAIL: Input: 0.9, Expected Output: -1, Output: %d .\\n"},\par
223                 arr[case_id]);\par
224         printf(temp);\par
225         fprintf(test_results, temp);\par
226     \}\par
227 \par
228     {\cf20 //Test case 11 input 1.0}\par
229     case_id = 10;\par
230     {\cf19 if} (arr[case_id] == 1)\par
231     \{\par
232         {\cf18 char} temp[100];\par
233         sprintf(temp, {\cf22 "PASS: Input: 1.0, Expected Output: 1, Output: %d .\\n"},\par
234                 arr[case_id]);\par
235         printf(temp);\par
236         fprintf(test_results, temp);\par
237     \}\par
238     {\cf19 else}\par
239     \{\par
240         {\cf18 char} temp[100];\par
241         sprintf(temp, {\cf22 "FAIL: Input: 1.0, Expected Output: 1, Output: %d .\\n"},\par
242                 arr[case_id]);\par
243         printf(temp);\par
244         fprintf(test_results, temp);\par
245     \}\par
246 \par
247     {\cf20 //Test case 12 input 100.1}\par
248     case_id = 11;\par
249     {\cf19 if} (arr[case_id] == 100)\par
250     \{\par
251         {\cf18 char} temp[100];\par
252         sprintf(temp, {\cf22 "PASS: Input: 100.1, Expected Output: 100, Output: %d .\\n"},\par
253                 arr[case_id]);\par
254         printf(temp);\par
255         fprintf(test_results, temp);\par
256     \}\par
257     {\cf19 else}\par
258     \{\par
259         {\cf18 char} temp[100];\par
260         sprintf(temp, {\cf22 "FAIL: Input: 100.1, Expected Output: 100, Output: %d .\\n"},\par
261                 arr[case_id]);\par
262         printf(temp);\par
263         fprintf(test_results, temp);\par
264     \}\par
265 \par
266     {\cf20 //Test case 13 input 100.0}\par
267     case_id = 12;\par
268     {\cf19 if} (arr[case_id] == 100)\par
269     \{\par
270         {\cf18 char} temp[100];\par
271         sprintf(temp, {\cf22 "PASS: Input: 100.0, Expected Output: 100, Output: %d .\\n"},\par
272                 arr[case_id]);\par
273         printf(temp);\par
274         fprintf(test_results, temp);\par
275     \}\par
276     {\cf19 else}\par
277     \{\par
278         {\cf18 char} temp[100];\par
279         sprintf(temp, {\cf22 "FAIL: Input: 100.0, Expected Output: 100, Output: %d .\\n"},\par
280                 arr[case_id]);\par
281         printf(temp);\par
282         fprintf(test_results, temp);\par
283     \}\par
284     fflush(test_results);\par
285     fclose(test_results);\par
286 \}\par
}
}
{\xe \v test_is_lift_on_floor\:test_functions.h}
{\xe \v test_functions.h\:test_is_lift_on_floor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_is_lift_on_floor (void )}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calls the function lift_on_floor.c with valid parameters. Prints the PASS /FAIL status ,by accessing the return from lift_on_floor function. results_is_lift_on_floor file contains the results. \par
}{
Definition at line 18 of file test_is_lift_on_floor.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19 \{\par
20     {\cf17 struct }elevator ele[3];\par
21     elevator_count = 3;\par
22     FILE *fp;\par
23     fp = fopen({\cf22 "test/results/results_is_lift_on_floor.txt"}, {\cf22 "w+"});\par
24     {\cf18 int} arr = is_lift_on_floor(ele, 1);\par
25     {\cf19 if} (arr != 0)\par
26     \{\par
27         fprintf(fp, {\cf22 "PASS;Input Parameter:Valid;is_lift_on_floor function is accesssed successfully .\\n"});\par
28         printf({\cf22 "PASS;Input Parameter:Valid;is_lift_on_floor function is accesssed successfully .\\n"});\par
29     \}\par
30     {\cf19 else}\par
31     \{\par
32         fprintf(fp, {\cf22 "FAIL;Input Parameter:Valid;is_lift_on_floor function cannot be accesssed  .\\n"});\par
33         printf({\cf22 "PASS;Input Parameter:Valid;is_lift_on_floor function is accesssed successfully .\\n"});\par
34     \}\par
35     fflush(fp);\par
36     fclose(fp);\par
37 \}\par
}
}
{\xe \v test_moving_lift_down\:test_functions.h}
{\xe \v test_functions.h\:test_moving_lift_down}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_moving_lift_down (void )}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function test the function moving_lift_down. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function tests array out of bounds check. Change elevator direction test. \par
}{
Definition at line 18 of file test_moving_lift_down.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19 \{\par
20     {\cf17 struct }elevator arr[3];\par
21     {\cf17 struct }elevator temp = \{0, 0, 0, 0, 0, 0, 0, 0, 0, 0\};\par
22     FILE *test_results = fopen({\cf22 "test/results/results_test_moving_lift_down.txt"}, {\cf22 "w"});\par
23     arr[1] = temp;\par
24     arr[2] = temp;\par
25     arr[0] = temp;\par
26 \par
27     elevator_count = 3;\par
28     {\cf18 char} *pass = {\cf22 "PASS:"};\par
29     {\cf18 char} *fail = {\cf22 "FAIL:"};\par
30 \par
31     {\cf18 int} result = moving_lift_down(arr, 3);\par
32 \par
33     {\cf19 if} (result == -1)\par
34     \{\par
35         {\cf18 char} temp[100];\par
36         sprintf(temp, {\cf22 "%s: Function returned %d Expected -1 . Array out of bound check working.\\n"},\par
37                 pass, result);\par
38         printf(temp);\par
39         fprintf(test_results, temp);\par
40     \}\par
41     {\cf19 else}\par
42     \{\par
43         {\cf18 char} temp[100];\par
44         sprintf(temp, {\cf22 "%s: Array values properly changed: direction_up = %d .\\}\par
45 {\cf22                         direction_down = %d, Return = %d\\n"},\par
46                 fail, arr[2].direction_up, arr[2].direction_down, result);\par
47         printf(temp);\par
48         fprintf(test_results, temp);\par
49     \}\par
50 \par
51     result = moving_lift_down(arr, 2);\par
52     {\cf19 if} (result != -1)\par
53     \{\par
54         result = arr[2].direction_up == 0 && arr[2].direction_down == 1;\par
55     \}\par
56     {\cf19 if} (result == -1)\par
57     \{\par
58         {\cf18 char} temp[100];\par
59         sprintf(temp, {\cf22 "%s: Function returned %d Expected 1.\\n"},\par
60                 fail, result);\par
61         printf(temp);\par
62         fprintf(test_results, temp);\par
63     \}\par
64     {\cf19 else}\par
65     \{\par
66         {\cf18 char} temp[100];\par
67         sprintf(temp, {\cf22 "%s: Array values properly changed: direction_up = %d .\\}\par
68 {\cf22                         direction_down = %d, Return = %d\\n"},\par
69                 pass, arr[2].direction_up, arr[2].direction_down, result);\par
70         printf(temp);\par
71         fprintf(test_results, temp);\par
72     \}\par
73 \par
74     result = arr[1].direction_up == 0 && arr[1].direction_down == 0;\par
75     {\cf19 if} (result == 1)\par
76     \{\par
77         {\cf18 char} temp[100];\par
78         sprintf(temp, {\cf22 "%s: Rest of Array Unchanged direction_up = %d ."}\par
79                       {\cf22 "direction_down = %d\\n"},\par
80                 pass, arr[1].direction_up, arr[1].direction_down);\par
81         printf(temp);\par
82         fprintf(test_results, temp);\par
83     \}\par
84 \par
85     {\cf20 //Reapeat the tests but with ptr to a dynamicall allovated array}\par
86 \par
87     {\cf17 struct }elevator *ptr_arr = malloc({\cf17 sizeof}({\cf17 struct} elevator) * 3);\par
88 \par
89     result = moving_lift_down(ptr_arr, 3);\par
90     {\cf19 if} (result == -1)\par
91     \{\par
92         {\cf18 char} temp[100];\par
93         sprintf(temp, {\cf22 "%s: Pointer: Function returned %d Expected -1 . Array out of bound check working.\\n"},\par
94                 pass, result);\par
95         printf(temp);\par
96         fprintf(test_results, temp);\par
97     \}\par
98     {\cf19 else}\par
99     \{\par
100         {\cf18 char} temp[100];\par
101         sprintf(temp, {\cf22 "%s: Pointer: Array values properly changed: direction_up = %d .\\}\par
102 {\cf22                         direction_down = %d, Return = %d\\n"},\par
103                 fail, ptr_arr[2].direction_up, ptr_arr[2].direction_down, result);\par
104         printf(temp);\par
105         fprintf(test_results, temp);\par
106     \}\par
107 \par
108     result = moving_lift_down(ptr_arr, 2);\par
109     {\cf19 if} (result != -1)\par
110     \{\par
111         result = ptr_arr[2].direction_up == 0 && ptr_arr[2].direction_down == 1;\par
112     \}\par
113     {\cf19 if} (result == -1)\par
114     \{\par
115         {\cf18 char} temp[100];\par
116         sprintf(temp, {\cf22 "%s: Pointer: Function returned %d Expected 1.\\n"},\par
117                 fail, result);\par
118         printf(temp);\par
119         fprintf(test_results, temp);\par
120     \}\par
121     {\cf19 else}\par
122     \{\par
123         {\cf18 char} temp[100];\par
124         sprintf(temp, {\cf22 "%s: Pointer: Array values properly changed: direction_up = %d .\\}\par
125 {\cf22                         direction_down = %d, Return = %d\\n"},\par
126                 pass, ptr_arr[2].direction_up, ptr_arr[2].direction_down, result);\par
127         printf(temp);\par
128         fprintf(test_results, temp);\par
129     \}\par
130 \par
131     result = ptr_arr[1].direction_up == 0 && ptr_arr[1].direction_down == 0;\par
132     {\cf19 if} (result == 1)\par
133     \{\par
134         {\cf18 char} temp[100];\par
135         sprintf(temp, {\cf22 "%s: Pointer: Rest of Array Unchanged direction_up = %d ."}\par
136                       {\cf22 "direction_down = %d\\n"},\par
137                 pass, ptr_arr[1].direction_up, ptr_arr[1].direction_down);\par
138         printf(temp);\par
139         fprintf(test_results, temp);\par
140     \}\par
141     fflush(test_results);\par
142     fclose(test_results);\par
143 \}\par
}
}
{\xe \v test_remove_passenger_floor\:test_functions.h}
{\xe \v test_functions.h\:test_remove_passenger_floor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_remove_passenger_floor (void )}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
tests the remove_passenger function. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests the removal of two passengers from a floor. The first removal causes the floor to contain the second passenger at start. the second removal replaces the passenger with NULL pointer. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
void does not return anything \par
}}}{
Definition at line 23 of file test_remove_passenger_floor.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23                                       \{\par
24 floor_count = 3;\par
25 {\cf17 struct }passenger** floors =({\cf17 struct }passenger**) calloc(3,{\cf17 sizeof}({\cf17 struct} passenger*));\par
26 {\cf17 struct }passenger dummy1 = \{0, 0, 0, 0, 10, 0\};\par
27 {\cf17 struct }passenger dummy2 = \{0, 0, 0, 0, 20, 0\};\par
28 FILE *f = fopen({\cf22 "test/results/results_remove_passenger_floor.txt"}, {\cf22 "w+"});\par
29 floors[1] =({\cf17 struct }passenger*) malloc({\cf17 sizeof}({\cf17 struct} passenger));\par
30 *(floors[1]) = dummy1;\par
31 floors[1]->next = ({\cf17 struct }passenger*) malloc({\cf17 sizeof}({\cf17 struct} passenger));\par
32 *(floors[1]->next) = dummy2;\par
33 remove_passenger_floor(floors,2);\par
34 {\cf19 if}(floors[1]->{\cf18 id} == dummy2.id)\{\par
35     fprintf(f,{\cf22 "PASS: Removed 1st Passenger. Id on floor is %d\\n"}, dummy2.id);\par
36     printf({\cf22 "PASS: Removed 1st Passenger. Id on floor is %d\\n"}, dummy2.id);\par
37 \}\par
38 {\cf19 else}\{\par
39     fprintf(f,{\cf22 "FAIL: Expected Passenger.Id %d Got : %d\\n"}, dummy2.id,floors[1]->id);\par
40     printf({\cf22 "FAIL: Expected Passenger.Id %d Got : %d\\n"}, dummy2.id,floors[1]->id);\par
41 \par
42 \}\par
43 remove_passenger_floor(floors,2);\par
44 {\cf19 if}(floors[1] == NULL)\{\par
45     fprintf(f,{\cf22 "PASS: Removed 2nd Passenger. Pointing to NULL %p\\n"}, floors[1]);\par
46     printf({\cf22 "PASS: Removed 2nd Passenger. Pointing to NULL %p\\n"}, floors[1]);\par
47 \}\par
48 {\cf19 else}\{\par
49     fprintf(f,{\cf22 "FAIL: Expected floor point to NULL.Instead Got : %p\\n"}, floors[1]);\par
50     printf({\cf22 "FAIL: Expected floor point to NULL.Instead Got : %p\\n"}, floors[1]); \par
51 \}\par
52 fflush(f);\par
53 fclose(f);\par
54 \par
55 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/test/test_add_passenger_floor.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/test/test_add_passenger_floor.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/test/test_add_passenger_floor.c}
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
provides blackbox unit testing for add_passenenger_floor function }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "add_passenger_floor.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <structures.h>}\par
{\f2 #include <globals.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_add_passenger_floor} (){\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b passenger} ** {\b floor_arr} = NULL\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
tests two conditions for add_passenger_floor function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b passenger} {\b add_passenger_dummy1} = \{0, 0, 0, 0, 10, 0\}{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b passenger} {\b add_passenger_dummy2} = \{0, 0, 0, 0, 20, 0\}{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

FILE * {\b f}{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
provides blackbox unit testing for add_passenenger_floor function \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v floor_arr\:test_add_passenger_floor.c}
{\xe \v test_add_passenger_floor.c\:floor_arr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b passenger}** floor_arr = NULL}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
tests two conditions for add_passenger_floor function. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The two test cases are adding to an empty floor. Adding to a floor already with an added passenger. The new passenger is added to the end of the floor list. \par
}{
Definition at line 27 of file test_add_passenger_floor.c.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/test/test_add_request_queue.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/test/test_add_request_queue.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/test/test_add_request_queue.c}
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains function test_add_request_queue() that provides unit testing for function {\b add_request_queue()}. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "add_request_queue.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include "structures.h"}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include "test_functions.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_add_request_queue} (void){\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains function test_add_request_queue() that provides unit testing for function {\b add_request_queue()}. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/test/test_average_waiting_time.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/test/test_average_waiting_time.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/test/test_average_waiting_time.c}
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
tests the average_waiting_time function if working fine or not }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include "../include/globals.h"}\par
{\f2 #include "../include/average_waiting_time.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_average_waiting_time} (void){\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
tests the average_waiting_time function if working fine or not \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Ritika Arora\par
}}@detail The function is to test average_waiting_time function for given inputs, the function returns right values or not. The average_waiting_time function is called with different inputs and its output is stored in one local variable. The max_time local variable should give the maximum of all the inputs given. The function checks if the max_time stores maximum of the inputs given to the max_waiting_time function , then the test passes and prints the result on console as well as writes on a file.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i No} \cell }{input is given to the function\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
void The function returns nothing. \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/test/test_cases.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/test/test_cases.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/test/test_cases.c}
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains all the tests and menue logic to choose each test. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "functions.h"}\par
{\f2 #include "test_functions.h"}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_cases} (void){\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains all the tests and menue logic to choose each test. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/test/test_cli_update.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/test/test_cli_update.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/test/test_cli_update.c}
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains test case for {\b cli_update()} function }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "cli_update.h"}\par
{\f2 #include "structures.h"}\par
{\f2 #include "globals.h"}\par
{\f2 #include "stdio.h"}\par
{\f2 #include "stdlib.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_cli_update} (void){\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b elevator} {\b dummy1} = \{1,0,0,1,0,3,10,30,15,0\}{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b elevator} {\b dummy2} = \{0,0,0,1,0,6,10,2,3,0\}{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b elevator} {\b dummy3} = \{1,0,0,0,0,0,10,5,0,0\}{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains test case for {\b cli_update()} function \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests the {\b cli_update()} function for basic screen clear test, display test and repeated function calls test.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/test/test_count_passenger.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/test/test_count_passenger.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/test/test_count_passenger.c}
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the test function for count_passenger(). }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_count_passenger} (void){\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the test function for count_passenger(). \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/test/test_create_elevator_array.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/test/test_create_elevator_array.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/test/test_create_elevator_array.c}
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains test cases for {\b create_elevator_array()} function. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include "structures.h"}\par
{\f2 #include "create_elevator_array.h"}\par
{\f2 #include "functions.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_create_elevator_array} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains test cases for {\b create_elevator_array()} function. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v test_create_elevator_array\:test_create_elevator_array.c}
{\xe \v test_create_elevator_array.c\:test_create_elevator_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_create_elevator_array (void )}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calls the function {\b create_elevator_array.c} with valid parameters. Prints the PASS /FAIL status ,by accessing the return from create_elevator_array function. results_create_elevator_array file contains the results. \par
}{
Definition at line 20 of file test_create_elevator_array.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21 \{\par
22     {\cf17 struct }elevator *elev;\par
23     printf({\cf22 "results_create_elevator_array file contains output \\n\\n "});\par
24     FILE *fp;\par
25     fp = freopen({\cf22 "test/results/results_create_elevator_array.txt"}, {\cf22 "w+"}, stdout);\par
26     elev = create_elevator_array(4);\par
27     {\cf19 if} (elev != NULL)\par
28     \{\par
29         printf({\cf22 "PASS;Input Parameter:Valid;array of structure elevator could be accessed .\\n"});\par
30     \}\par
31     {\cf19 else}\par
32     \{\par
33         printf({\cf22 "FAIL;Input Parameter:Valid;array of structure elevator could not be accessed .\\n"});\par
34     \}\par
35     fflush(fp);\par
36     fclose(fp);\par
37 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/test/test_create_floor_array.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/test/test_create_floor_array.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/test/test_create_floor_array.c}
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To test create_floor_array function which creates array for every floor. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <stdbool.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b passenger}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
structure to store important information about a passenger. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_create_floor_array} (void){\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b passenger} {\b dummy}{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To test create_floor_array function which creates array for every floor. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Hariprasad Munusamy - {\f2 HariprasadMunusamy@cmail.carleton.ca} \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Writes the test case log in output file \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/test/test_input_after_stop.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/test/test_input_after_stop.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/test/test_input_after_stop.c}
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When the simulation encounters a emergency stop situation input_after_stop function is invoked prompting for the user input. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_input_after_stop} (void){\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When the simulation encounters a emergency stop situation input_after_stop function is invoked prompting for the user input. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Hariprasad Munusamy - {\f2 HariprasadMunusamy@cmail.carleton.ca} \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
int Returns the user input (1 - to continue the simulation, 0 - to end the simulation) \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/test/test_input_floors.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/test/test_input_floors.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/test/test_input_floors.c}
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the test cases for testing the {\b input_floors()} function. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include "input_floors.h"}\par
{\f2 #include "test_functions.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_input_floors} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the test cases for testing the {\b input_floors()} function. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v test_input_floors\:test_input_floors.c}
{\xe \v test_input_floors.c\:test_input_floors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_input_floors (void )}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calls the function {\b input_floors.c} with input from input_input_floors.txt. Prints the PASS /FAIL status ,by accessing the return from input_floors function. results_input_floors file contains the results. \par
}{
Definition at line 20 of file test_input_floors.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21 \{\par
22     FILE *test_results;\par
23     test_results = fopen({\cf22 "test/results/results_input_floors.txt"}, {\cf22 "w"});\par
24     freopen({\cf22 "test/data/input_input_floors.txt"}, {\cf22 "r"}, stdin);\par
25     {\cf18 int} arr[13];\par
26     arr[0] = input_floors();\par
27     arr[1] = input_floors();\par
28     arr[2] = input_floors();\par
29     arr[3] = input_floors();\par
30     arr[4] = input_floors();\par
31     arr[5] = input_floors();\par
32     arr[6] = input_floors();\par
33     arr[7] = input_floors();\par
34     arr[8] = input_floors();\par
35     arr[9] = input_floors();\par
36     arr[10] = input_floors();\par
37     arr[11] = input_floors();\par
38     arr[12] = input_floors();\par
39     arr[13] = input_floors();\par
40 \par
41     {\cf18 int} case_id = 0;\par
42     {\cf20 //Test case 1 -input abcd}\par
43 \par
44     {\cf19 if} (arr[0] == -1)\par
45     \{\par
46         {\cf18 char} temp[100];\par
47         sprintf(temp, {\cf22 "PASS: Input: abcd, Expected Output: -1, Output: %d .\\n"},\par
48                 arr[0]);\par
49         printf(temp);\par
50         fprintf(test_results, temp);\par
51     \}\par
52 \par
53     {\cf19 else}\par
54     \{\par
55         {\cf18 char} temp[100];\par
56         sprintf(temp, {\cf22 "FAIL: Input: abcd, Expected Output: -1, Output: %d .\\n"},\par
57                 arr[0]);\par
58         printf(temp);\par
59         fprintf(test_results, temp);\par
60     \}\par
61     {\cf20 //Test case 2- input abcd123}\par
62     {\cf19 if} (arr[1] == -1)\par
63     \{\par
64         {\cf18 char} temp[100];\par
65         sprintf(temp, {\cf22 "PASS: Input: abcd123, Expected Output: -1, Output: %d .\\n"},\par
66                 arr[0]);\par
67         printf(temp);\par
68         fprintf(test_results, temp);\par
69     \}\par
70 \par
71     {\cf19 else}\par
72     \{\par
73         {\cf18 char} temp[100];\par
74         sprintf(temp, {\cf22 "FAIL: Input: abcd123, Expected Output: -1, Output: %d .\\n"},\par
75                 arr[0]);\par
76         printf(temp);\par
77         fprintf(test_results, temp);\par
78     \}\par
79     {\cf20 //Test case 3- input 0}\par
80     {\cf19 if} (arr[2] == -1)\par
81     \{\par
82         {\cf18 char} temp[100];\par
83         sprintf(temp, {\cf22 "PASS: Input: 0, Expected Output: -1, Output: %d .\\n"},\par
84                 arr[0]);\par
85         printf(temp);\par
86         fprintf(test_results, temp);\par
87     \}\par
88 \par
89     {\cf19 else}\par
90     \{\par
91         {\cf18 char} temp[100];\par
92         sprintf(temp, {\cf22 "FAIL: Input: 0, Expected Output: -1, Output: %d .\\n"},\par
93                 arr[0]);\par
94         printf(temp);\par
95         fprintf(test_results, temp);\par
96     \}\par
97     {\cf20 //Test case 4- input -100}\par
98     {\cf19 if} (arr[2] == -1)\par
99     \{\par
100         {\cf18 char} temp[100];\par
101         sprintf(temp, {\cf22 "PASS: Input: -100, Expected Output: -1, Output: %d .\\n"},\par
102                 arr[0]);\par
103         printf(temp);\par
104         fprintf(test_results, temp);\par
105     \}\par
106 \par
107     {\cf19 else}\par
108     \{\par
109         {\cf18 char} temp[100];\par
110         sprintf(temp, {\cf22 "FAIL: Input: -100, Expected Output: -1, Output: %d .\\n"},\par
111                 arr[0]);\par
112         printf(temp);\par
113         fprintf(test_results, temp);\par
114     \}\par
115 \par
116     {\cf20 //Test case 5 -input 101}\par
117     {\cf19 if} (arr[4] == -1)\par
118     \{\par
119         {\cf18 char} temp[100];\par
120         sprintf(temp, {\cf22 "PASS: Input: 101, Expected Output: -1, Output: %d .\\n"},\par
121                 arr[4]);\par
122         printf(temp);\par
123         fprintf(test_results, temp);\par
124     \}\par
125     {\cf19 else}\par
126     \{\par
127         {\cf18 char} temp[100];\par
128         sprintf(temp, {\cf22 "FAIL: Input: 101, Expected Output: -1, Output: %d .\\n"},\par
129                 arr[4]);\par
130         printf(temp);\par
131         fprintf(test_results, temp);\par
132     \}\par
133 \par
134     {\cf20 //Test case 6 -input 1}\par
135     {\cf19 if} (arr[5] == 1)\par
136     \{\par
137         {\cf18 char} temp[100];\par
138         sprintf(temp, {\cf22 "PASS: Input: 1, Expected Output: 1, Output: %d .\\n"},\par
139                 arr[5]);\par
140         printf(temp);\par
141         fprintf(test_results, temp);\par
142     \}\par
143     {\cf19 else}\par
144     \{\par
145         {\cf18 char} temp[100];\par
146         sprintf(temp, {\cf22 "FAIL: Input: 1, Expected Output: 1, Output: %d .\\n"},\par
147                 arr[5]);\par
148         printf(temp);\par
149         fprintf(test_results, temp);\par
150     \}\par
151 \par
152     {\cf20 //Test case 7 -input 100}\par
153     case_id = 6;\par
154     {\cf19 if} (arr[case_id] == 100)\par
155     \{\par
156         {\cf18 char} temp[100];\par
157         sprintf(temp, {\cf22 "PASS: Input: 100, Expected Output: 100, Output: %d .\\n"},\par
158                 arr[case_id]);\par
159         printf(temp);\par
160         fprintf(test_results, temp);\par
161     \}\par
162     {\cf19 else}\par
163     \{\par
164         {\cf18 char} temp[100];\par
165         sprintf(temp, {\cf22 "FAIL: Input: 100, Expected Output: 100, Output: %d .\\n"},\par
166                 arr[case_id]);\par
167         printf(temp);\par
168         fprintf(test_results, temp);\par
169     \}\par
170 \par
171     {\cf20 //Test case 8 input 50}\par
172     case_id = 7;\par
173     {\cf19 if} (arr[case_id] == 50)\par
174     \{\par
175         {\cf18 char} temp[100];\par
176         sprintf(temp, {\cf22 "PASS: Input: 50, Expected Output: 50, Output: %d .\\n"},\par
177                 arr[case_id]);\par
178         printf(temp);\par
179         fprintf(test_results, temp);\par
180     \}\par
181     {\cf19 else}\par
182     \{\par
183         {\cf18 char} temp[100];\par
184         sprintf(temp, {\cf22 "FAIL: Input: 50, Expected Output: 50, Output: %d .\\n"},\par
185                 arr[case_id]);\par
186         printf(temp);\par
187         fprintf(test_results, temp);\par
188     \}\par
189 \par
190     {\cf20 //Test case 9 input 23.3}\par
191     case_id = 8;\par
192     {\cf19 if} (arr[case_id] == 23)\par
193     \{\par
194         {\cf18 char} temp[100];\par
195         sprintf(temp, {\cf22 "PASS: Input: 23.3, Expected Output: 23, Output: %d .\\n"},\par
196                 arr[case_id]);\par
197         printf(temp);\par
198         fprintf(test_results, temp);\par
199     \}\par
200     {\cf19 else}\par
201     \{\par
202         {\cf18 char} temp[100];\par
203         sprintf(temp, {\cf22 "FAIL: Input: 23.3, Expected Output: 23, Output: %d .\\n"},\par
204                 arr[case_id]);\par
205         printf(temp);\par
206         fprintf(test_results, temp);\par
207     \}\par
208 \par
209     {\cf20 //Test case 10 input 0.9}\par
210     case_id = 9;\par
211     {\cf19 if} (arr[case_id] == -1)\par
212     \{\par
213         {\cf18 char} temp[100];\par
214         sprintf(temp, {\cf22 "PASS: Input: 0.9, Expected Output: -1, Output: %d .\\n"},\par
215                 arr[case_id]);\par
216         printf(temp);\par
217         fprintf(test_results, temp);\par
218     \}\par
219     {\cf19 else}\par
220     \{\par
221         {\cf18 char} temp[100];\par
222         sprintf(temp, {\cf22 "FAIL: Input: 0.9, Expected Output: -1, Output: %d .\\n"},\par
223                 arr[case_id]);\par
224         printf(temp);\par
225         fprintf(test_results, temp);\par
226     \}\par
227 \par
228     {\cf20 //Test case 11 input 1.0}\par
229     case_id = 10;\par
230     {\cf19 if} (arr[case_id] == 1)\par
231     \{\par
232         {\cf18 char} temp[100];\par
233         sprintf(temp, {\cf22 "PASS: Input: 1.0, Expected Output: 1, Output: %d .\\n"},\par
234                 arr[case_id]);\par
235         printf(temp);\par
236         fprintf(test_results, temp);\par
237     \}\par
238     {\cf19 else}\par
239     \{\par
240         {\cf18 char} temp[100];\par
241         sprintf(temp, {\cf22 "FAIL: Input: 1.0, Expected Output: 1, Output: %d .\\n"},\par
242                 arr[case_id]);\par
243         printf(temp);\par
244         fprintf(test_results, temp);\par
245     \}\par
246 \par
247     {\cf20 //Test case 12 input 100.1}\par
248     case_id = 11;\par
249     {\cf19 if} (arr[case_id] == 100)\par
250     \{\par
251         {\cf18 char} temp[100];\par
252         sprintf(temp, {\cf22 "PASS: Input: 100.1, Expected Output: 100, Output: %d .\\n"},\par
253                 arr[case_id]);\par
254         printf(temp);\par
255         fprintf(test_results, temp);\par
256     \}\par
257     {\cf19 else}\par
258     \{\par
259         {\cf18 char} temp[100];\par
260         sprintf(temp, {\cf22 "FAIL: Input: 100.1, Expected Output: 100, Output: %d .\\n"},\par
261                 arr[case_id]);\par
262         printf(temp);\par
263         fprintf(test_results, temp);\par
264     \}\par
265 \par
266     {\cf20 //Test case 13 input 100.0}\par
267     case_id = 12;\par
268     {\cf19 if} (arr[case_id] == 100)\par
269     \{\par
270         {\cf18 char} temp[100];\par
271         sprintf(temp, {\cf22 "PASS: Input: 100.0, Expected Output: 100, Output: %d .\\n"},\par
272                 arr[case_id]);\par
273         printf(temp);\par
274         fprintf(test_results, temp);\par
275     \}\par
276     {\cf19 else}\par
277     \{\par
278         {\cf18 char} temp[100];\par
279         sprintf(temp, {\cf22 "FAIL: Input: 100.0, Expected Output: 100, Output: %d .\\n"},\par
280                 arr[case_id]);\par
281         printf(temp);\par
282         fprintf(test_results, temp);\par
283     \}\par
284     fflush(test_results);\par
285     fclose(test_results);\par
286 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/test/test_input_lifts.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/test/test_input_lifts.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/test/test_input_lifts.c}
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains function test_input_lifts() that provides unit testing for function {\b input_lifts()}. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include "input_lifts.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_input_lifts} (void){\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains function test_input_lifts() that provides unit testing for function {\b input_lifts()}. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/test/test_is_lift_empty.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/test/test_is_lift_empty.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/test/test_is_lift_empty.c}
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests if the is_lift_empty function works fine or not. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include "../include/globals.h"}\par
{\f2 #include "../include/structures.h"}\par
{\f2 #include "../include/is_lift_empty.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_is_lift_empty} (void){\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests if the is_lift_empty function works fine or not. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Ritika Arora\par
}}@detail The function tests with different values if the output comes correct or not. elevator_count which is a global variable has been set to a fix value The test cases are as below:{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
For array with passenger count equal to the maximum number of passengers of the lift, and index value as 0 or less than the elevator count the output is 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
For array with passenger count less than the maximum number of passengers of the lift, and index value as 1 or less than the elevator count the output is 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
For array with passenger count more than the maximum number of passengers of the lift, and index value as 2 or less than the elevator count the output is 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
For array with index value as 3 or greater than or equal to the elevator count the output is -1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
For an empty array, the output is -1 and the program exits\par}
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i The} \cell }{function takes no input\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
void The function returns nothing. \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/test/test_is_lift_on_floor.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/test/test_is_lift_on_floor.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/test/test_is_lift_on_floor.c}
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains test cases for the function {\b is_lift_on_floor()} }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include "globals.h"}\par
{\f2 #include "structures.h"}\par
{\f2 #include "is_lift_on_floor.h"}\par
{\f2 #include "functions.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_is_lift_on_floor} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains test cases for the function {\b is_lift_on_floor()} \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v test_is_lift_on_floor\:test_is_lift_on_floor.c}
{\xe \v test_is_lift_on_floor.c\:test_is_lift_on_floor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_is_lift_on_floor (void )}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calls the function lift_on_floor.c with valid parameters. Prints the PASS /FAIL status ,by accessing the return from lift_on_floor function. results_is_lift_on_floor file contains the results. \par
}{
Definition at line 18 of file test_is_lift_on_floor.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19 \{\par
20     {\cf17 struct }elevator ele[3];\par
21     elevator_count = 3;\par
22     FILE *fp;\par
23     fp = fopen({\cf22 "test/results/results_is_lift_on_floor.txt"}, {\cf22 "w+"});\par
24     {\cf18 int} arr = is_lift_on_floor(ele, 1);\par
25     {\cf19 if} (arr != 0)\par
26     \{\par
27         fprintf(fp, {\cf22 "PASS;Input Parameter:Valid;is_lift_on_floor function is accesssed successfully .\\n"});\par
28         printf({\cf22 "PASS;Input Parameter:Valid;is_lift_on_floor function is accesssed successfully .\\n"});\par
29     \}\par
30     {\cf19 else}\par
31     \{\par
32         fprintf(fp, {\cf22 "FAIL;Input Parameter:Valid;is_lift_on_floor function cannot be accesssed  .\\n"});\par
33         printf({\cf22 "PASS;Input Parameter:Valid;is_lift_on_floor function is accesssed successfully .\\n"});\par
34     \}\par
35     fflush(fp);\par
36     fclose(fp);\par
37 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/test/test_main.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/test/test_main.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/test/test_main.c}
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
serves as an entry point for the test_cases functions. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include "test_functions.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_cases} (){\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b main} (){\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
serves as an entry point for the test_cases functions. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/test/test_max_waiting_time.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/test/test_max_waiting_time.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/test/test_max_waiting_time.c}
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
tests the max_waiting_time function if working fine or not }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include "../include/globals.h"}\par
{\f2 #include "../include/max_waiting_time.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_max_waiting_time} (void){\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
tests the max_waiting_time function if working fine or not \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Ritika Arora\par
}}@detail The function is to test max_waiting_time function for given inputs, the function returns right values or not. The max_waiting_time function is called with different inputs and its output is stored in one local variable. The max_time local variable should give the maximum of all the inputs given. The function checks if the max_time stores maximum of the inputs given to the max_waiting_time function , then the test passes and prints the result on console as well as writes on a file.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i No} \cell }{input is given to the function\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
void The function returns nothing. \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/test/test_moving_lift_down.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/test/test_moving_lift_down.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/test/test_moving_lift_down.c}
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains test cases for {\b moving_lift_down.c} }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "moving_lift_down.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include "structures.h"}\par
{\f2 #include "globals.h"}\par
{\f2 #include "stdlib.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_moving_lift_down} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function test the function moving_lift_down. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains test cases for {\b moving_lift_down.c} \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v test_moving_lift_down\:test_moving_lift_down.c}
{\xe \v test_moving_lift_down.c\:test_moving_lift_down}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_moving_lift_down (void )}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function test the function moving_lift_down. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function tests array out of bounds check. Change elevator direction test. \par
}{
Definition at line 18 of file test_moving_lift_down.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19 \{\par
20     {\cf17 struct }elevator arr[3];\par
21     {\cf17 struct }elevator temp = \{0, 0, 0, 0, 0, 0, 0, 0, 0, 0\};\par
22     FILE *test_results = fopen({\cf22 "test/results/results_test_moving_lift_down.txt"}, {\cf22 "w"});\par
23     arr[1] = temp;\par
24     arr[2] = temp;\par
25     arr[0] = temp;\par
26 \par
27     elevator_count = 3;\par
28     {\cf18 char} *pass = {\cf22 "PASS:"};\par
29     {\cf18 char} *fail = {\cf22 "FAIL:"};\par
30 \par
31     {\cf18 int} result = moving_lift_down(arr, 3);\par
32 \par
33     {\cf19 if} (result == -1)\par
34     \{\par
35         {\cf18 char} temp[100];\par
36         sprintf(temp, {\cf22 "%s: Function returned %d Expected -1 . Array out of bound check working.\\n"},\par
37                 pass, result);\par
38         printf(temp);\par
39         fprintf(test_results, temp);\par
40     \}\par
41     {\cf19 else}\par
42     \{\par
43         {\cf18 char} temp[100];\par
44         sprintf(temp, {\cf22 "%s: Array values properly changed: direction_up = %d .\\}\par
45 {\cf22                         direction_down = %d, Return = %d\\n"},\par
46                 fail, arr[2].direction_up, arr[2].direction_down, result);\par
47         printf(temp);\par
48         fprintf(test_results, temp);\par
49     \}\par
50 \par
51     result = moving_lift_down(arr, 2);\par
52     {\cf19 if} (result != -1)\par
53     \{\par
54         result = arr[2].direction_up == 0 && arr[2].direction_down == 1;\par
55     \}\par
56     {\cf19 if} (result == -1)\par
57     \{\par
58         {\cf18 char} temp[100];\par
59         sprintf(temp, {\cf22 "%s: Function returned %d Expected 1.\\n"},\par
60                 fail, result);\par
61         printf(temp);\par
62         fprintf(test_results, temp);\par
63     \}\par
64     {\cf19 else}\par
65     \{\par
66         {\cf18 char} temp[100];\par
67         sprintf(temp, {\cf22 "%s: Array values properly changed: direction_up = %d .\\}\par
68 {\cf22                         direction_down = %d, Return = %d\\n"},\par
69                 pass, arr[2].direction_up, arr[2].direction_down, result);\par
70         printf(temp);\par
71         fprintf(test_results, temp);\par
72     \}\par
73 \par
74     result = arr[1].direction_up == 0 && arr[1].direction_down == 0;\par
75     {\cf19 if} (result == 1)\par
76     \{\par
77         {\cf18 char} temp[100];\par
78         sprintf(temp, {\cf22 "%s: Rest of Array Unchanged direction_up = %d ."}\par
79                       {\cf22 "direction_down = %d\\n"},\par
80                 pass, arr[1].direction_up, arr[1].direction_down);\par
81         printf(temp);\par
82         fprintf(test_results, temp);\par
83     \}\par
84 \par
85     {\cf20 //Reapeat the tests but with ptr to a dynamicall allovated array}\par
86 \par
87     {\cf17 struct }elevator *ptr_arr = malloc({\cf17 sizeof}({\cf17 struct} elevator) * 3);\par
88 \par
89     result = moving_lift_down(ptr_arr, 3);\par
90     {\cf19 if} (result == -1)\par
91     \{\par
92         {\cf18 char} temp[100];\par
93         sprintf(temp, {\cf22 "%s: Pointer: Function returned %d Expected -1 . Array out of bound check working.\\n"},\par
94                 pass, result);\par
95         printf(temp);\par
96         fprintf(test_results, temp);\par
97     \}\par
98     {\cf19 else}\par
99     \{\par
100         {\cf18 char} temp[100];\par
101         sprintf(temp, {\cf22 "%s: Pointer: Array values properly changed: direction_up = %d .\\}\par
102 {\cf22                         direction_down = %d, Return = %d\\n"},\par
103                 fail, ptr_arr[2].direction_up, ptr_arr[2].direction_down, result);\par
104         printf(temp);\par
105         fprintf(test_results, temp);\par
106     \}\par
107 \par
108     result = moving_lift_down(ptr_arr, 2);\par
109     {\cf19 if} (result != -1)\par
110     \{\par
111         result = ptr_arr[2].direction_up == 0 && ptr_arr[2].direction_down == 1;\par
112     \}\par
113     {\cf19 if} (result == -1)\par
114     \{\par
115         {\cf18 char} temp[100];\par
116         sprintf(temp, {\cf22 "%s: Pointer: Function returned %d Expected 1.\\n"},\par
117                 fail, result);\par
118         printf(temp);\par
119         fprintf(test_results, temp);\par
120     \}\par
121     {\cf19 else}\par
122     \{\par
123         {\cf18 char} temp[100];\par
124         sprintf(temp, {\cf22 "%s: Pointer: Array values properly changed: direction_up = %d .\\}\par
125 {\cf22                         direction_down = %d, Return = %d\\n"},\par
126                 pass, ptr_arr[2].direction_up, ptr_arr[2].direction_down, result);\par
127         printf(temp);\par
128         fprintf(test_results, temp);\par
129     \}\par
130 \par
131     result = ptr_arr[1].direction_up == 0 && ptr_arr[1].direction_down == 0;\par
132     {\cf19 if} (result == 1)\par
133     \{\par
134         {\cf18 char} temp[100];\par
135         sprintf(temp, {\cf22 "%s: Pointer: Rest of Array Unchanged direction_up = %d ."}\par
136                       {\cf22 "direction_down = %d\\n"},\par
137                 pass, ptr_arr[1].direction_up, ptr_arr[1].direction_down);\par
138         printf(temp);\par
139         fprintf(test_results, temp);\par
140     \}\par
141     fflush(test_results);\par
142     fclose(test_results);\par
143 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/test/test_passenger_take_in.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/test/test_passenger_take_in.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/test/test_passenger_take_in.c}
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains function test_passenger_take_in() that provides unit testing for function passenger_take_in(). }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "passengers_take_in.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include "globals.h"}\par
{\f2 #include "structures.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b test_passenger_take_in} (void){\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b elevator} {\b dummy} = \{0, 0, 0, 0, 0, 0, 0, 0, 0, 0\}{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b elevator} {\b dummy_2} = \{0, 0, 0, 0, 0, 0, 0, 0, 0, 0\}{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b passenger} {\b dummy_pass} = \{1, 0, 0, 4, 0, 0\}{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

FILE * {\b f}{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains function test_passenger_take_in() that provides unit testing for function passenger_take_in(). \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/test/test_read_passenger.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/test/test_read_passenger.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/test/test_read_passenger.c}
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains tests for {\b read_passenger()} function. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include "structures.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_read_passenger} (void){\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains tests for {\b read_passenger()} function. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/test/test_remove_passenger_floor.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/test/test_remove_passenger_floor.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/test/test_remove_passenger_floor.c}
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains tests for remove_passenger_floor }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "remove_passenger_floor.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include "structures.h"}\par
{\f2 #include "globals.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b test_remove_passenger_floor} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
tests the remove_passenger function. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains tests for remove_passenger_floor \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v test_remove_passenger_floor\:test_remove_passenger_floor.c}
{\xe \v test_remove_passenger_floor.c\:test_remove_passenger_floor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void test_remove_passenger_floor (void )}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
tests the remove_passenger function. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests the removal of two passengers from a floor. The first removal causes the floor to contain the second passenger at start. the second removal replaces the passenger with NULL pointer. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
void does not return anything \par
}}}{
Definition at line 23 of file test_remove_passenger_floor.c.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23                                       \{\par
24 floor_count = 3;\par
25 {\cf17 struct }passenger** floors =({\cf17 struct }passenger**) calloc(3,{\cf17 sizeof}({\cf17 struct} passenger*));\par
26 {\cf17 struct }passenger dummy1 = \{0, 0, 0, 0, 10, 0\};\par
27 {\cf17 struct }passenger dummy2 = \{0, 0, 0, 0, 20, 0\};\par
28 FILE *f = fopen({\cf22 "test/results/results_remove_passenger_floor.txt"}, {\cf22 "w+"});\par
29 floors[1] =({\cf17 struct }passenger*) malloc({\cf17 sizeof}({\cf17 struct} passenger));\par
30 *(floors[1]) = dummy1;\par
31 floors[1]->next = ({\cf17 struct }passenger*) malloc({\cf17 sizeof}({\cf17 struct} passenger));\par
32 *(floors[1]->next) = dummy2;\par
33 remove_passenger_floor(floors,2);\par
34 {\cf19 if}(floors[1]->{\cf18 id} == dummy2.id)\{\par
35     fprintf(f,{\cf22 "PASS: Removed 1st Passenger. Id on floor is %d\\n"}, dummy2.id);\par
36     printf({\cf22 "PASS: Removed 1st Passenger. Id on floor is %d\\n"}, dummy2.id);\par
37 \}\par
38 {\cf19 else}\{\par
39     fprintf(f,{\cf22 "FAIL: Expected Passenger.Id %d Got : %d\\n"}, dummy2.id,floors[1]->id);\par
40     printf({\cf22 "FAIL: Expected Passenger.Id %d Got : %d\\n"}, dummy2.id,floors[1]->id);\par
41 \par
42 \}\par
43 remove_passenger_floor(floors,2);\par
44 {\cf19 if}(floors[1] == NULL)\{\par
45     fprintf(f,{\cf22 "PASS: Removed 2nd Passenger. Pointing to NULL %p\\n"}, floors[1]);\par
46     printf({\cf22 "PASS: Removed 2nd Passenger. Pointing to NULL %p\\n"}, floors[1]);\par
47 \}\par
48 {\cf19 else}\{\par
49     fprintf(f,{\cf22 "FAIL: Expected floor point to NULL.Instead Got : %p\\n"}, floors[1]);\par
50     printf({\cf22 "FAIL: Expected floor point to NULL.Instead Got : %p\\n"}, floors[1]); \par
51 \}\par
52 fflush(f);\par
53 fclose(f);\par
54 \par
55 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/Work/git_repo/elevator_simulator/test/test_remove_passenger_queue.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/Work/git_repo/elevator_simulator/test/test_remove_passenger_queue.c}
{\xe \v C:/Users/Work/git_repo/elevator_simulator/test/test_remove_passenger_queue.c}
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains function test_remove_passenger_queue() that provides unit testing for function {\b remove_passenger_queue()}. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "remove_passenger_queue.h"}\par
{\f2 #include "structures.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b test_remove_passenger_queue} (void){\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b passenger} {\b temp} = \{0, 0, 0, 0, 0, 0\}{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

FILE * {\b f}{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file contains function test_remove_passenger_queue() that provides unit testing for function {\b remove_passenger_queue()}. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Maaz Jamal \par
}}}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}